


ARM Macro Assembler    Page 1 


    1 00000000         ;Exercise 06
    2 00000000         ;****************************************************************
    3 00000000         ;Exercies 5 which is usesd to demonstrate chrypotographic
    4 00000000         ;and decifering techniques
    5 00000000         ;Name:  Joel Yuhas
    6 00000000         ;Date:  3/10/2016
    7 00000000         ;Class:  CMPE-250
    8 00000000         ;Section:  Lab section 2 2:00pm to 3:50pm
    9 00000000         ;---------------------------------------------------------------
   10 00000000         ;Keil Template for KL46
   11 00000000         ;R. W. Melton
   12 00000000         ;April 3, 2015
   13 00000000         ;****************************************************************
   14 00000000         ;Assembler directives
   15 00000000                 THUMB
   17 00000000         ;****************************************************************
   18 00000000         ;Include files
   19 00000000                 GET              MKL46Z4.s   ;Included by start.s
   21 00000000         ;****************************************************************
   22 00000000         ;EQUates
   23 00000000         
   24 00000000         ;---------------------------------------------------------------
   25 00000000         ;NVIC_ICER
   26 00000000         ;31-00:CLRENA=masks for HW IRQ sources;
   27 00000000         ;             read:   0 = unmasked;   1 = masked
   28 00000000         ;             write:  0 = no effect;  1 = mask
   29 00000000         ;12:UART0 IRQ mask
   30 00000000 00001000 
                       NVIC_ICER_UART0_MASK
                               EQU              UART0_IRQ_MASK
   31 00000000         ;---------------------------------------------------------------
   32 00000000         ;NVIC_ICPR
   33 00000000         ;31-00:CLRPEND=pending status for HW IRQ sources;
   34 00000000         ;             read:   0 = not pending;  1 = pending
   35 00000000         ;             write:  0 = no effect;
   36 00000000         ;                     1 = change status to not pending
   37 00000000         ;12:UART0 IRQ pending status
   38 00000000 00001000 
                       NVIC_ICPR_UART0_MASK
                               EQU              UART0_IRQ_MASK
   39 00000000         ;---------------------------------------------------------------
   40 00000000         ;NVIC_IPR0-NVIC_IPR7



ARM Macro Assembler    Page 2 


   41 00000000         ;2-bit priority:  00 = highest; 11 = lowest
   42 00000000 00000003 
                       UART0_IRQ_PRIORITY
                               EQU              3
   43 00000000 000000C0 
                       NVIC_IPR_UART0_MASK
                               EQU              (3 << UART0_PRI_POS)
   44 00000000 000000C0 
                       NVIC_IPR_UART0_PRI_3
                               EQU              (UART0_IRQ_PRIORITY << UART0_PRI_POS)
   45 00000000         ;---------------------------------------------------------------
   46 00000000         ;NVIC_ISER
   47 00000000         ;31-00:SETENA=masks for HW IRQ sources;
   48 00000000         ;             read:   0 = masked;     1 = unmasked
   49 00000000         ;             write:  0 = no effect;  1 = unmask
   50 00000000         ;12:UART0 IRQ mask
   51 00000000 00001000 
                       NVIC_ISER_UART0_MASK
                               EQU              UART0_IRQ_MASK
   52 00000000         ;---------------------------------------------------------------
   53 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   54 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   55 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   56 00000000         ;---------------------------------------------------------------
   57 00000000         ;Port A
   59 00000000 01000200 
                       PORT_PCR_SET_PTA1_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   61 00000000 01000200 
                       PORT_PCR_SET_PTA2_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   62 00000000         ;---------------------------------------------------------------
   63 00000000         ;SIM_SCGC4
   64 00000000         ;1->10:UART0 clock gate control (enabled)
   65 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   66 00000000         ;---------------------------------------------------------------
   67 00000000         ;SIM_SCGC5
   68 00000000         ;1->09:Port A clock gate control (enabled)
   69 00000000         ;Use provided SIM_SCGC5_PORTA_MASK
   70 00000000         ;---------------------------------------------------------------



ARM Macro Assembler    Page 3 


   71 00000000         ;SIM_SOPT2
   72 00000000         ;01=27-26:UART0SRC=UART0 clock source select
   73 00000000         ;         (PLLFLLSEL determines MCGFLLCLK' or MCGPLLCLK/2)
   74 00000000         ; 1=   16:PLLFLLSEL=PLL/FLL clock select (MCGPLLCLK/2)
   76 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGPLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
   78 00000000 04010000 
                       SIM_SOPT2_UART0_MCGPLLCLK_DIV2
                               EQU              (SIM_SOPT2_UART0SRC_MCGPLLCLK :OR: SIM_SOPT2_PLLFLLSEL_MASK)
   79 00000000         ;---------------------------------------------------------------
   80 00000000         ;SIM_SOPT5
   81 00000000         ; 0->   16:UART0 open drain enable (disabled)
   82 00000000         ; 0->   02:UART0 receive data select (UART0_RX)
   83 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
   87 00000000 00010007 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:                                  SIM_SOPT
5_UART0RXSRC_MASK :OR:                                  SIM_SOPT5_UART0TXSRC_MASK)
   88 00000000         ;---------------------------------------------------------------
   89 00000000         ;UART0_BDH
   90 00000000         ;    0->  7:LIN break detect IE (disabled)
   91 00000000         ;    0->  6:RxD input active edge IE (disabled)
   92 00000000         ;    0->  5:Stop bit number select (1)
   93 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
   94 00000000         ;UART0CLK is MCGPLLCLK/2
   95 00000000         ;MCGPLLCLK is 96 MHz
   96 00000000         ;MCGPLLCLK/2 is 48 MHz
   97 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   98 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
   99 00000000         ;---------------------------------------------------------------
  100 00000000         ;UART0_BDL
  101 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
  102 00000000         ;UART0CLK is MCGPLLCLK/2
  103 00000000         ;MCGPLLCLK is 96 MHz
  104 00000000         ;MCGPLLCLK/2 is 48 MHz
  105 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
  106 00000000 00000038 
                       UART0_BDL_9600
                               EQU              0x38



ARM Macro Assembler    Page 4 


  107 00000000         ;---------------------------------------------------------------
  108 00000000         ;UART0_C1
  109 00000000         ;0-->7:LOOPS=loops select (normal)
  110 00000000         ;0-->6:DOZEEN=doze enable (disabled)
  111 00000000         ;0-->5:RSRC=receiver source select (internal--no effect LOOPS=0)
  112 00000000         ;0-->4:M=9- or 8-bit mode select 
  113 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
  114 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
  115 00000000         ;0-->2:IDLE=idle line type select (idle begins after start bit)
  116 00000000         ;0-->1:PE=parity enable (disabled)
  117 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
  118 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
  119 00000000         ;---------------------------------------------------------------
  120 00000000         ;UART0_C2
  121 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
  122 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
  123 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
  124 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
  125 00000000         ;1-->3:TE=transmitter enable (enabled)
  126 00000000         ;1-->2:RE=receiver enable (enabled)
  127 00000000         ;0-->1:RWU=receiver wakeup control (normal)
  128 00000000         ;0-->0:SBK=send break (disabled, normal)
  129 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2_RE_MASK)
  130 00000000 0000002C 
                       UART0_C2_T_RI
                               EQU              (UART0_C2_RIE_MASK :OR: UART0_C2_T_R)
  131 00000000 000000AC 
                       UART0_C2_TI_RI
                               EQU              (UART0_C2_TIE_MASK :OR: UART0_C2_T_RI)
  132 00000000         ;---------------------------------------------------------------
  133 00000000         ;UART0_C3
  134 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  135 00000000         ;           10th data bit for transmitter (not used M10=0)
  136 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  137 00000000         ;           10th data bit for receiver (not used M10=0)
  138 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  139 00000000         ;            (no effect LOOPS=0)
  140 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)



ARM Macro Assembler    Page 5 


  141 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  142 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  143 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  144 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  145 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
  146 00000000         ;---------------------------------------------------------------
  147 00000000         ;UART0_C4
  148 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled)
  149 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled)
  150 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  151 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  152 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  153 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  154 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  155 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  156 00000000         ;---------------------------------------------------------------
  157 00000000         ;UART0_C5
  158 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  159 00000000         ;  0-->  6:Reserved; read-only; always 0
  160 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)
  161 00000000         ;000-->4-2:Reserved; read-only; always 0
  162 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only)
  163 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
  164 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  165 00000000         ;---------------------------------------------------------------
  166 00000000         ;UART0_S1
  167 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
  168 00000000         ;0-->6:TC=transmission complete flag; read-only
  169 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  170 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  171 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear)
  172 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  173 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  174 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)



ARM Macro Assembler    Page 6 


  175 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              0x1F
  176 00000000         ;---------------------------------------------------------------
  177 00000000         ;UART0_S2
  178 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  179 00000000         ;             write 1 to clear
  180 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear)
  181 00000000         ;              write 1 to clear
  182 00000000         ;0-->5:(reserved); read-only; always 0
  183 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  184 00000000         ;0-->3:RWUID=receive wake-up idle detect
  185 00000000         ;0-->2:BRK13=break character generation length (10)
  186 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  187 00000000         ;0-->0:RAF=receiver active flag; read-only
  188 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              0xC0
  189 00000000         ;---------------------------------------------------------------
  190 00000000         
  191 00000000 0000000D 
                       CR      EQU              0x0D
  192 00000000 0000000A 
                       LF      EQU              0x0A
  193 00000000 0000004F 
                       MAX_STRING
                               EQU              79
  194 00000000         
  195 00000000 00000000 
                       IN_PTR  EQU              0
  196 00000000 00000004 
                       OUT_PTR EQU              4
  197 00000000 00000008 
                       BUF_STRT
                               EQU              8
  198 00000000 0000000C 
                       BUF_PAST
                               EQU              12
  199 00000000 00000010 
                       BUF_SIZE
                               EQU              16
  200 00000000 00000011 



ARM Macro Assembler    Page 7 


                       NUM_ENQD
                               EQU              17
  201 00000000         
  202 00000000         
  203 00000000 00000004 
                       Q_BUF_SZ
                               EQU              4
  204 00000000 00000050 
                       TRxQ_BUF_SZ
                               EQU              80
  205 00000000 00000012 
                       Q_REC_SZ
                               EQU              18
  206 00000000         
  207 00000000         
  208 00000000         ;****************************************************************
  209 00000000         ;Program
  210 00000000         ;Linker requires Reset_Handler
  211 00000000                 AREA             MyCode,CODE,READONLY
  212 00000000                 ENTRY
  213 00000000                 EXPORT           Reset_Handler
  214 00000000                 IMPORT           Startup
  215 00000000         Reset_Handler
  216 00000000         main
  217 00000000         ;---------------------------------------------------------------
  218 00000000         ;Mask interrupts
  219 00000000 B672            CPSID            I
  220 00000002         ;KL46 system startup with 48-MHz system clock
  221 00000002 F7FF FFFE       BL               Startup
  222 00000006         ;---------------------------------------------------------------
  223 00000006         ;---------------------- HEADER -------------------------
  224 00000006         ;Program creates a Queue and has EnQueue and Dequeue functonality
  225 00000006         ;as well as being able to display help and status tables
  226 00000006         ;
  227 00000006         ;these subroutines include but are not limited to
  228 00000006         ;----------InitQueue
  229 00000006         ;----------Enqueue
  230 00000006         ;----------Dequeue
  231 00000006         ;----------PutNumHex
  232 00000006         ;----------GetStringSB
  233 00000006         ;----------PutStringSB
  234 00000006         ;----------PutNumU



ARM Macro Assembler    Page 8 


  235 00000006         ;----------PutChar
  236 00000006         ;----------GetChar
  237 00000006         
  238 00000006         
  239 00000006         ;-----**NEW**----
  240 00000006         ;----------UART0_ISR
  241 00000006         ;----------Init_UART_IRQ
  242 00000006         ;----------PutNumSB
  243 00000006         ;
  244 00000006         ;the program also used a number of other subroutines that allowed it
  245 00000006         ;to read in the input of the useer
  246 00000006         
  247 00000006         
  248 00000006         ;>>>>> begin main program code <<<<< 
  249 00000006 F000 F9A0       BL               Init_UART0_IRQ ;initializing UART0
  250 0000000A 490C            LDR              R1,=QRecord ;loading and preparing the main queue
  251 0000000C 480C            LDR              R0,=QBuffer ;that will be used
  252 0000000E 2204            MOVS             R2,#Q_BUF_SZ
  253 00000010 F000 F8C0       BL               InitQueue   ;initializing main queue
  254 00000014         Loop                                 ;infinite loop 
  255 00000014         
  256 00000014 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  257 00000016 480B            LDR              R0,=InitString ;loading the initial output of "Type a string command (g,
                                                            i,l,p):"
  258 00000018 F000 F96B       BL               PutStringSB
  259 0000001C         
  260 0000001C         LoopInit
  261 0000001C F000 FA07       BL               GetChar     ;getting the first user input
  262 00000020 0007            MOVS             R7,R0       ;saving the original value for later
  263 00000022 285A            CMP              R0, #'Z'    ;checking to see if upper case
  264 00000024 D910            BLS              UpperCase   ;if it is uppercase, branch and fix it
  265 00000026         
  266 00000026         Back                                 ;back from uppercase fix
  267 00000026 2864            CMP              R0, #'d'    ;checking if 'd'
  268 00000028 D01C            BEQ              CorrectD
  269 0000002A 2865            CMP              R0, #'e'    ;checking if 'e'
  270 0000002C D02E            BEQ              CorrectE
  271 0000002E 2868            CMP              R0, #'h'    ;checking if 'h'
  272 00000030 D047            BEQ              CorrectH
  273 00000032 2870            CMP              R0, #'p'    ;checking if 'p'
  274 00000034 D052            BEQ              CorrectP
  275 00000036 2873            CMP              R0, #'s'    ;checking if 's'



ARM Macro Assembler    Page 9 


  276 00000038 D078            BEQ              CorrectS
  277 0000003A         
  278 0000003A         
  279 0000003A E7EF            B                LoopInit    ;looping forever
  280 0000003C         
  281 0000003C                 ALIGN
  282 0000003C 00000000 
              00000000 
              00000000         LTORG
  283 00000048         
  284 00000048         ;--------------------------------- UpperCase --------------------------------
  285 00000048         ;Recieves R0
  286 00000048         ;Outputs Converted into R0, original in R7
  287 00000048         ;Subroutine used to convert uppercase input into lowercase equivilant
  288 00000048         UpperCase
  289 00000048 0007            MOVS             R7,R0       ;saves initial value in R7
  290 0000004A 3020            ADDS             R0,R0,#32   ;converts to lower case
  291 0000004C E7EB            B                Back
  292 0000004E         
  293 0000004E         Correct
  294 0000004E B501            PUSH             {R0, LR}
  295 00000050 0038            MOVS             R0,R7       ;printing original value
  296 00000052 F000 F9E1       BL               PutChar
  297 00000056         
  298 00000056 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  299 00000058 F000 F9DE       BL               PutChar
  300 0000005C 200A            MOVS             R0,#LF
  301 0000005E F000 F9DB       BL               PutChar
  302 00000062 BD01            POP              {R0, PC}
  303 00000064         
  304 00000064         ;----------------------------------- D ------------------------------------
  305 00000064         ;Calls if D is pushed, calls Dequeue
  306 00000064         CorrectD
  307 00000064 B478            PUSH             {R3,R4,R5,R6}
  308 00000066 F7FF FFF2       BL               Correct     ;Base correct subroutine that sets up subroutines
  309 0000006A         
  310 0000006A 49F5            LDR              R1,=QRecord ;loading queue record in to R1
  311 0000006C F000 F89C       BL               DeQueue     ;dequeuing
  312 00000070         
  313 00000070         
  314 00000070 D207            BCS              ZERO_1      ;is called if carry flag is set, meaning a failure
  315 00000072 F000 F9D1       BL               PutChar     ;placing character



ARM Macro Assembler    Page 10 


  316 00000076 48F3            LDR              R0,=DQGDS
  317 00000078 214F            MOVS             R1,#MAX_STRING
  318 0000007A F000 F93A       BL               PutStringSB
  319 0000007E         
  320 0000007E         
  321 0000007E BC78            POP              {R3,R4,R5,R6}
  322 00000080         
  323 00000080 E062            B                CorrectS_1  ;jumps to status subroutine
  324 00000082         
  325 00000082         ;-------------------------------- Zero Case ------------------------------------
  326 00000082         ;used to print out the failure case
  327 00000082         ZERO_1
  328 00000082 48F1            LDR              R0,=Failure ;failure string
  329 00000084 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  330 00000086 F000 F934       BL               PutStringSB
  331 0000008A         
  332 0000008A E05D            B                CorrectS_1  ;jumps to status subroutine
  333 0000008C         
  334 0000008C         ;----------------------------------- E ---------------------------------
  335 0000008C         ;Recives character to enqueu in R0
  336 0000008C         ;Calls if the user inputed E, does enqueu command and takes in a character
  337 0000008C         CorrectE
  338 0000008C F7FF FFDF       BL               Correct     ;Base correct subroutine that sets up subroutines
  339 00000090 49EE            LDR              R1,=MAX_STRING
  340 00000092 48EF            LDR              R0,=CTE     ;loading string
  341 00000094 F000 F92D       BL               PutStringSB
  342 00000098 F000 F9C9       BL               GetChar
  343 0000009C 0002            MOVS             R2,R0
  344 0000009E         
  345 0000009E F000 F9BB       BL               PutChar
  346 000000A2 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  347 000000A4 F000 F9B8       BL               PutChar
  348 000000A8 200A            MOVS             R0,#LF
  349 000000AA F000 F9B5       BL               PutChar
  350 000000AE         
  351 000000AE 0010            MOVS             R0,R2
  352 000000B0 49E3            LDR              R1,=QRecord ;initializing QRecord
  353 000000B2 F000 F89C       BL               Enqueue     ;enqueuing
  354 000000B6         
  355 000000B6         
  356 000000B6 D367            BCC              CarryClear_01
  357 000000B8 48E3            LDR              R0,=Failure ;failure print



ARM Macro Assembler    Page 11 


  358 000000BA 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  359 000000BC F000 F919       BL               PutStringSB
  360 000000C0         
  361 000000C0         
  362 000000C0 E042            B                CorrectS_1  ;jumps to status subroutine
  363 000000C2         
  364 000000C2         
  365 000000C2         ;----------------------------------- H ------------------------------------
  366 000000C2         ;Called if the user inputed H, this is the help command
  367 000000C2         CorrectH
  368 000000C2 F7FF FFC4       BL               Correct     ;Base correct subroutine that sets up subroutines
  369 000000C6 48E3            LDR              R0,=Help
  370 000000C8 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  371 000000CA F000 F912       BL               PutStringSB
  372 000000CE         
  373 000000CE 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  374 000000D0 F000 F9A2       BL               PutChar
  375 000000D4 200A            MOVS             R0,#LF
  376 000000D6 F000 F99F       BL               PutChar
  377 000000DA         
  378 000000DA E79B            B                Loop        ;no status, so loops back
  379 000000DC         
  380 000000DC         ;----------------------------------- P ----------------------------------------
  381 000000DC         ;Called if th euser inputed P, this is the print command
  382 000000DC         CorrectP
  383 000000DC F7FF FFB7       BL               Correct     ;Base correct subroutine that sets up subroutines
  384 000000E0 203E            MOVS             R0,#'>'     ;printing '>'
  385 000000E2 F000 F999       BL               PutChar
  386 000000E6         
  387 000000E6 49D6            LDR              R1,=QRecord ;loading QRecord
  388 000000E8 7C4C            LDRB             R4,[R1,#NUM_ENQD]
  389 000000EA 684D            LDR              R5,[R1,#OUT_PTR]
  390 000000EC 688E            LDR              R6,[R1,#BUF_STRT]
  391 000000EE 68CB            LDR              R3,[R1,#BUF_PAST]
  392 000000F0         
  393 000000F0         
  394 000000F0 2200            MOVS             R2,#0
  395 000000F2 42A2            CMP              R2,R4
  396 000000F4 D009            BEQ              DONE_P      ;branches equals if size is equal
  397 000000F6         Loop_P
  398 000000F6 4294            CMP              R4,R2       ;checks if counter equals num_enqud
  399 000000F8 D007            BEQ              DONE_P



ARM Macro Assembler    Page 12 


  400 000000FA 429D            CMP              R5,R3       ;checks if out ptr = buf past
  401 000000FC D00F            BEQ              OVER_P
  402 000000FE         
  403 000000FE 7828            LDRB             R0,[R5,#0]  ;placing the character that is currently enqueued by the poi
                                                            nter
  404 00000100 F000 F98A       BL               PutChar
  405 00000104         
  406 00000104 1C6D            ADDS             R5,R5,#1    ;increments
  407 00000106 1C52            ADDS             R2,R2,#1
  408 00000108         
  409 00000108 E7F5            B                Loop_P
  410 0000010A         
  411 0000010A         DONE_P                               ;done with printing
  412 0000010A         
  413 0000010A 203C            MOVS             R0,#'<'     ;printing '>'
  414 0000010C F000 F984       BL               PutChar
  415 00000110         
  416 00000110 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  417 00000112 F000 F981       BL               PutChar
  418 00000116 200A            MOVS             R0,#LF
  419 00000118 F000 F97E       BL               PutChar
  420 0000011C E014            B                CorrectS_1  ;jumps to status subroutine
  421 0000011E         
  422 0000011E         OVER_P
  423 0000011E 0035            MOVS             R5,R6       ;if the inpointer reaches the buffer limit but does not equa
                                                            l in_ptr,
  424 00000120 7828            LDRB             R0,[R5,#0]  ;jump back to the begginign
  425 00000122 F000 F979       BL               PutChar
  426 00000126 1C6D            ADDS             R5,R5,#1    ;increments
  427 00000128 1C52            ADDS             R2,R2,#1
  428 0000012A E7E4            B                Loop_P
  429 0000012C         
  430 0000012C         
  431 0000012C         ;----------------------------------- S -------------------------------------------
  432 0000012C         ;if the user implement S then the Status is printed
  433 0000012C         ;Takes in a the user input and then procedes to print the queue
  434 0000012C         ;in the order that they would be removed
  435 0000012C         CorrectS
  436 0000012C 0038            MOVS             R0,R7       ;printing original value
  437 0000012E F000 F973       BL               PutChar
  438 00000132 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  439 00000134 F000 F970       BL               PutChar



ARM Macro Assembler    Page 13 


  440 00000138 200A            MOVS             R0,#LF
  441 0000013A F000 F96D       BL               PutChar
  442 0000013E 48C6            LDR              R0,=Status  ;printing Status
  443 00000140 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  444 00000142 F000 F8D6       BL               PutStringSB
  445 00000146 E7FF            B                CorrectS_1
  446 00000148         
  447 00000148         
  448 00000148         CorrectS_1                           ;Basic status print used by all subroutines
  449 00000148 48C4            LDR              R0,=Ln
  450 0000014A 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  451 0000014C F000 F8D1       BL               PutStringSB
  452 00000150         
  453 00000150 49BB            LDR              R1,=QRecord
  454 00000152 6808            LDR              R0,[R1,#IN_PTR]
  455 00000154 F000 F86E       BL               PutNumHex
  456 00000158         
  457 00000158 48C1            LDR              R0,=OUT
  458 0000015A 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  459 0000015C F000 F8C9       BL               PutStringSB
  460 00000160         
  461 00000160 49B7            LDR              R1,=QRecord
  462 00000162 6848            LDR              R0,[R1,#OUT_PTR]
  463 00000164 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  464 00000166 F000 F865       BL               PutNumHex
  465 0000016A         
  466 0000016A 48BE            LDR              R0,=Num
  467 0000016C 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  468 0000016E F000 F8C0       BL               PutStringSB
  469 00000172         
  470 00000172 49B3            LDR              R1,=QRecord
  471 00000174 7C48            LDRB             R0,[R1,#NUM_ENQD]
  472 00000176 F000 F8A8       BL               PutNumU
  473 0000017A         
  474 0000017A 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  475 0000017C F000 F94C       BL               PutChar
  476 00000180 200A            MOVS             R0,#LF
  477 00000182 F000 F949       BL               PutChar
  478 00000186         
  479 00000186 E745            B                Loop
  480 00000188         
  481 00000188         



ARM Macro Assembler    Page 14 


  482 00000188         ;------------------------------ CarryClear_01-----------------------------------------
  483 00000188         ;used by multiple subrotines to print out success
  484 00000188         CarryClear_01
  485 00000188 48B7            LDR              R0,=Success
  486 0000018A 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  487 0000018C F000 F8B1       BL               PutStringSB
  488 00000190         
  489 00000190 E7DA            B                CorrectS_1  ;jumps to status subroutine
  490 00000192         
  491 00000192         
  492 00000192         
  493 00000192 E7FE            B                .
  494 00000194         
  495 00000194         ;>>>>> begin subroutine code <<<<<
  496 00000194         
  497 00000194         
  498 00000194         ;-------------------------------- InitQueue ------------------------------
  499 00000194         ;initilizes the queue, R1 must be queue record, can be used for multiple
  500 00000194         ;queues
  501 00000194         InitQueue
  502 00000194         
  503 00000194 B501            PUSH             {R0,LR}
  504 00000196         
  505 00000196 6008            STR              R0,[R1,#IN_PTR]
  506 00000198 6048            STR              R0,[R1,#OUT_PTR]
  507 0000019A 6088            STR              R0,[R1,#BUF_STRT]
  508 0000019C 1880            ADDS             R0,R0,R2
  509 0000019E 60C8            STR              R0,[R1,#BUF_PAST]
  510 000001A0 740A            STRB             R2,[R1,#BUF_SIZE]
  511 000001A2 2000            MOVS             R0,#0
  512 000001A4 7448            STRB             R0,[R1,#NUM_ENQD]
  513 000001A6         
  514 000001A6 BD01            POP              {R0,PC}
  515 000001A8         
  516 000001A8         
  517 000001A8         ;-------------------------------- DeQueue --------------------------------
  518 000001A8         ;R1 Address of Queue record structure
  519 000001A8         ;C flag succes(0)
  520 000001A8         ;the deuque subrotine, dequeus and advances the pointer
  521 000001A8         DeQueue
  522 000001A8         
  523 000001A8 B5FE            PUSH             {R1-R7,LR}



ARM Macro Assembler    Page 15 


  524 000001AA         
  525 000001AA 7C4C            LDRB             R4,[R1,#NUM_ENQD] ;loading values
  526 000001AC 680D            LDR              R5,[R1,#IN_PTR]
  527 000001AE 688E            LDR              R6,[R1,#BUF_STRT]
  528 000001B0 684F            LDR              R7,[R1,#OUT_PTR]
  529 000001B2 68CB            LDR              R3,[R1,#BUF_PAST]
  530 000001B4         
  531 000001B4         
  532 000001B4 2C00            CMP              R4,#0       ;checks if size is zero
  533 000001B6 D00F            BEQ              Failed_Dequeue
  534 000001B8 783A            LDRB             R2,[R7,#0]
  535 000001BA         
  536 000001BA 1C7F            ADDS             R7,R7,#1
  537 000001BC 1E64            SUBS             R4,R4,#1
  538 000001BE         
  539 000001BE         
  540 000001BE 744C            STRB             R4,[R1,#NUM_ENQD] ;storing back into loacation
  541 000001C0 604F            STR              R7,[R1,#OUT_PTR]
  542 000001C2         
  543 000001C2 429F            CMP              R7,R3
  544 000001C4 D010            BEQ              InPointer_Bigger2 ;if pointer procgressing past buffer limit,
  545 000001C6         ;then advacne back
  546 000001C6         Done_Success
  547 000001C6 F3EF 8000       MRS              R0,APSR     ; sets C flag to clear
  548 000001CA 2020            MOVS             R0,#0x20
  549 000001CC 0609            LSLS             R1,R1,#24
  550 000001CE 4388            BICS             R0,R0,R1
  551 000001D0 F380 8800       MSR              APSR,R0
  552 000001D4 0010            MOVS             R0,R2
  553 000001D6         
  554 000001D6         DoneD1
  555 000001D6 BDFE            POP              {R1-R7,PC}
  556 000001D8         
  557 000001D8         Failed_Dequeue
  558 000001D8         ;Unsuccesfull
  559 000001D8 F3EF 8000       MRS              R0,APSR     ;manually sets C flag to set
  560 000001DC 2120            MOVS             R1,#0x20
  561 000001DE 0609            LSLS             R1,R1,#24
  562 000001E0 4308            ORRS             R0,R0,R1
  563 000001E2 F380 8800       MSR              APSR,R0
  564 000001E6 E7F6            B                DoneD1
  565 000001E8         



ARM Macro Assembler    Page 16 


  566 000001E8         InPointer_Bigger2
  567 000001E8 0037            MOVS             R7,R6       ;manually moving the pointer back to start
  568 000001EA 604F            STR              R7,[R1,#OUT_PTR]
  569 000001EC E7EB            B                Done_Success
  570 000001EE         
  571 000001EE         
  572 000001EE         ;--------------------------------- EnQueue ------------------------------------
  573 000001EE         ;R0 Character to enqueue
  574 000001EE         ;R1 Address of Queue record structure
  575 000001EE         ;C flag succes(0)
  576 000001EE         ;Enqueues the recived value and advances
  577 000001EE         Enqueue
  578 000001EE         
  579 000001EE B57F            PUSH             {R0-R6,LR}
  580 000001F0         
  581 000001F0 7C0B            LDRB             R3,[R1,#BUF_SIZE] ;initializing the queue structure
  582 000001F2 7C4C            LDRB             R4,[R1,#NUM_ENQD]
  583 000001F4 680D            LDR              R5,[R1,#IN_PTR]
  584 000001F6 688E            LDR              R6,[R1,#BUF_STRT]
  585 000001F8 68CF            LDR              R7,[R1,#BUF_PAST]
  586 000001FA         
  587 000001FA         
  588 000001FA 429C            CMP              R4,R3
  589 000001FC D012            BEQ              Failed_Enqueue ;fails if the queue is full
  590 000001FE 7028            STRB             R0,[R5,#0]  ;stores value
  591 00000200 1C6D            ADDS             R5,R5,#1    ;advances counters
  592 00000202 1C64            ADDS             R4,R4,#1
  593 00000204         
  594 00000204 600D            STR              R5,[R1,#IN_PTR] ;stores back
  595 00000206 744C            STRB             R4,[R1,#NUM_ENQD]
  596 00000208         
  597 00000208 42BD            CMP              R5,R7
  598 0000020A D008            BEQ              InPointer_Bigger1 ;if inpointer reaches end of the queue, go back
  599 0000020C         
  600 0000020C         Done
  601 0000020C F3EF 8000       MRS              R0,APSR     ; sets C flag to clear
  602 00000210 2020            MOVS             R0,#0x20
  603 00000212 0609            LSLS             R1,R1,#24
  604 00000214 4388            BICS             R0,R0,R1
  605 00000216 F380 8800       MSR              APSR,R0
  606 0000021A 2000            MOVS             R0,#0
  607 0000021C         



ARM Macro Assembler    Page 17 


  608 0000021C         
  609 0000021C BD7F            POP              {R0-R6,PC}
  610 0000021E         
  611 0000021E         InPointer_Bigger1                    ;if the inpointer is bigger, manually set it back
  612 0000021E 0035            MOVS             R5,R6
  613 00000220 600D            STR              R5,[R1,#IN_PTR]
  614 00000222 E7F3            B                Done
  615 00000224         
  616 00000224         Failed_Enqueue
  617 00000224 F3EF 8000       MRS              R0,APSR     ; manually sets C flag to set
  618 00000228 2120            MOVS             R1,#0x20
  619 0000022A 0609            LSLS             R1,R1,#24
  620 0000022C 4308            ORRS             R0,R0,R1
  621 0000022E F380 8800       MSR              APSR,R0
  622 00000232 BD7F            POP              {R0-R6,PC}
  623 00000234         
  624 00000234         
  625 00000234         
  626 00000234         ;---------------------------- PutNumHex----------------------
  627 00000234         ;takes in value at R0
  628 00000234         ;doesnt output any values
  629 00000234         ;converts address into hex value, prints to terminal
  630 00000234         PutNumHex
  631 00000234 B53F            PUSH             {R0-R5,LR}
  632 00000236         
  633 00000236 221C            MOVS             R2,#28      ;defining constants that will need to be added
  634 00000238 230F            MOVS             R3,#0x0000000F
  635 0000023A 0004            MOVS             R4,R0
  636 0000023C 2508            MOVS             R5,#8
  637 0000023E         
  638 0000023E         Loop_PNH
  639 0000023E         
  640 0000023E 40D0            LSRS             R0,R0,R2    ;shifiting by how much we need
  641 00000240 4018            ANDS             R0,R3
  642 00000242 2809            CMP              R0,#9
  643 00000244 D908            BLS              Number_PNH  ;checks if number
  644 00000246 3037            ADDS             R0,R0,#55   ;if not assume its letter
  645 00000248 F000 F8E6       BL               PutChar
  646 0000024C 0020            MOVS             R0,R4
  647 0000024E         
  648 0000024E 1F12            SUBS             R2,R2,#4    ;incrementing 
  649 00000250 1E6D            SUBS             R5,R5,#1



ARM Macro Assembler    Page 18 


  650 00000252 2D00            CMP              R5,#0
  651 00000254 D009            BEQ              Done_PNH
  652 00000256 E7F2            B                Loop_PNH
  653 00000258         
  654 00000258         
  655 00000258         
  656 00000258         Number_PNH
  657 00000258 3030            ADDS             R0,R0,#0x00000030 ;speical case for number 
  658 0000025A F000 F8DD       BL               PutChar
  659 0000025E 0020            MOVS             R0,R4
  660 00000260         
  661 00000260 1F12            SUBS             R2,R2,#4
  662 00000262 1E6D            SUBS             R5,R5,#1
  663 00000264 2D00            CMP              R5,#0
  664 00000266 D000            BEQ              Done_PNH
  665 00000268 E7E9            B                Loop_PNH
  666 0000026A         
  667 0000026A         Done_PNH
  668 0000026A BD3F            POP              {R0-R5,PC}
  669 0000026C         
  670 0000026C         
  671 0000026C         ;---------------------------------PUTNUMSB----------------------------
  672 0000026C         ;takes value from R0
  673 0000026C         ;doesnt output any values except for PSVR
  674 0000026C         ;prints to the terminal the least significant bit
  675 0000026C         PutNumSB
  676 0000026C B503            PUSH             {R0-R1,LR}
  677 0000026E 210F            MOVS             R1,#0x0000000F
  678 00000270 4008            ANDS             R0,R1
  679 00000272 F000 F82A       BL               PutNumU
  680 00000276 F000 F8CF       BL               PutChar
  681 0000027A BD03            POP              {R0-R1,PC}
  682 0000027C         
  683 0000027C         ;------------------------------- GETSTRINGSB -------------------------- 
  684 0000027C         ;Recieves in R0,
  685 0000027C         ;Outputs string to R0
  686 0000027C         ;takes a string that is typed in and then puts into R0
  687 0000027C         GetStringSB
  688 0000027C B51F            PUSH             { R0 - R4, LR }
  689 0000027E 2300            MOVS             R3,#0       ;initializing counter
  690 00000280 0004            MOVS             R4,R0       ;storing adress
  691 00000282 1E49            SUBS             R1,R1,#1    ;subtracting buffer capacity



ARM Macro Assembler    Page 19 


  692 00000284         
  693 00000284         Loop1A                               ;super loop
  694 00000284 F000 F8D3       BL               GetChar     ;checking if input is "enter"
  695 00000288 280D            CMP              R0, #CR
  696 0000028A D00B            BEQ              Enter       ;branching if it is
  697 0000028C         
  698 0000028C         
  699 0000028C 4299            CMP              R1,R3       ;checking if index = buffer cpacity
  700 0000028E D004            BEQ              Skip        ;if it is, skip
  701 00000290 54E0            STRB             R0,[R4,R3]  ;otherwise store in adress with value (R0) at address (R4) o
                                                            ffset of increment (R3)
  702 00000292 1C5B            ADDS             R3,R3,#1    ;incrementing counter
  703 00000294         
  704 00000294         
  705 00000294 F000 F8C0       BL               PutChar     ;printing it
  706 00000298 E7F4            B                Loop1A      ;looping almost forever
  707 0000029A         
  708 0000029A         Skip
  709 0000029A F000 F8C8       BL               GetChar     ;triggered if buffercapacity over limit and ignores everythi
                                                            ng until enter is hit
  710 0000029E 280D            CMP              R0, #CR
  711 000002A0 D000            BEQ              Enter
  712 000002A2 E7FA            B                Skip
  713 000002A4         Enter                                ;if enter was hit
  714 000002A4 2000            MOVS             R0,#0       ;storing '0' at end
  715 000002A6 54E0            STRB             R0,[R4,R3]
  716 000002A8 200D            MOVS             R0,#CR      ;printing new line
  717 000002AA F000 F8B5       BL               PutChar
  718 000002AE 200A            MOVS             R0,#LF
  719 000002B0 F000 F8B2       BL               PutChar
  720 000002B4 BD1F            POP              { R0 - R4, PC }
  721 000002B6         
  722 000002B6         
  723 000002B6         ;------------------------------ LENGTHSTRINGSB -------------------------  
  724 000002B6         LengthStringSB
  725 000002B6 B50A            PUSH             { R1, R3, LR }
  726 000002B8         
  727 000002B8 2200            MOVS             R2,#0       ;initializing counter
  728 000002BA         
  729 000002BA         Loop2
  730 000002BA 5C83            LDRB             R3,[R0,R2]  ;loading value in string
  731 000002BC 2B00            CMP              R3,#0       ;checking if '0', if it is, run away



ARM Macro Assembler    Page 20 


  732 000002BE D003            BEQ              Ende
  733 000002C0 428A            CMP              R2, R1      ;checking if counter = buffercapacity, if it does, run away
  734 000002C2 D001            BEQ              Ende
  735 000002C4 1C52            ADDS             R2,R2, #1
  736 000002C6         
  737 000002C6 E7F8            B                Loop2       ;looping almost forver
  738 000002C8         Ende
  739 000002C8         
  740 000002C8 BD0A            POP              { R1, R3, PC }
  741 000002CA         
  742 000002CA         
  743 000002CA         ;---------------------------------- PUTNUMU ------------------------------
  744 000002CA         ;prints the number in decimal form in R0
  745 000002CA         ;does not output any registers
  746 000002CA         PutNumU
  747 000002CA B507            PUSH             { R0 - R2, LR }
  748 000002CC 2200            MOVS             R2,#0       ;initializng counter
  749 000002CE         Loop3
  750 000002CE 0001            MOVS             R1, R0      ;setting up for DIVU (R1 divedend, R0 divider)
  751 000002D0 200A            MOVS             R0, #10
  752 000002D2 F000 F81B       BL               DIVU        ;calling DIVU
  753 000002D6 B402            PUSH             {R1}        ;storing in stack because it gets values in revers order
  754 000002D8 1C52            ADDS             R2,R2,#1
  755 000002DA 2800            CMP              R0, #0      ;checking done
  756 000002DC D000            BEQ              Out         ;if it is, end
  757 000002DE E7F6            B                Loop3
  758 000002E0         
  759 000002E0         Out
  760 000002E0 BC01            POP              {R0}        ;finishing up
  761 000002E2 1E52            SUBS             R2,R2,#1
  762 000002E4 3030            ADDS             R0,R0,#'0'
  763 000002E6 F000 F897       BL               PutChar
  764 000002EA 2A00            CMP              R2,#0
  765 000002EC D000            BEQ              Done4
  766 000002EE E7F7            B                Out
  767 000002F0         
  768 000002F0         Done4
  769 000002F0 BD07            POP              { R0 - R2, PC }
  770 000002F2         
  771 000002F2         
  772 000002F2         ;--------------------------------- PUTSTRINGSB -----------------------------
  773 000002F2         ;prints the string stored in R0 to terminal



ARM Macro Assembler    Page 21 


  774 000002F2         ;does not output any registers
  775 000002F2         PutStringSB
  776 000002F2 B50F            PUSH             { R0, R1, R2, R3, LR }
  777 000002F4         
  778 000002F4 2300            MOVS             R3,#0       ;counter
  779 000002F6 0002            MOVS             R2,R0       ;R2 gets adress
  780 000002F8         
  781 000002F8         Loop4
  782 000002F8 428B            CMP              R3,R1       ;compares counter with MAX SIZE
  783 000002FA D006            BEQ              Ende2
  784 000002FC         
  785 000002FC 5CD0            LDRB             R0,[R2,R3]  ;loads value at R2 offset R3 into R0
  786 000002FE 2800            CMP              R0,#0       ;checks if null terminator
  787 00000300 D003            BEQ              Ende2
  788 00000302         
  789 00000302 F000 F889       BL               PutChar     ;prints
  790 00000306 1C5B            ADDS             R3,R3, #1   ;adds to counter
  791 00000308         
  792 00000308 E7F6            B                Loop4
  793 0000030A         Ende2
  794 0000030A         
  795 0000030A BD0F            POP              { R0, R1, R2, R3, PC }
  796 0000030C         
  797 0000030C         
  798 0000030C         ;------------------------------------- DIVU --------------------------------
  799 0000030C         ;takes in Diveded (R1) and Divisor (R0)
  800 0000030C         ;returns the dividen amount
  801 0000030C         DIVU
  802 0000030C         
  803 0000030C B404            PUSH             {R2}        ;Pushing R2 to save
  804 0000030E 2200            MOVS             R2,#0
  805 00000310 2800            CMP              R0,#0       ;checks if Divide by zero
  806 00000312 D009            BEQ              DIV_BY_ZERO
  807 00000314         
  808 00000314         
  809 00000314         
  810 00000314 2900            CMP              R1,#0       ;checks if Dividend is zero
  811 00000316 D00F            BEQ              EndIFF
  812 00000318         
  813 00000318 4281    While   CMP              R1,R0       ;the main loop where Dividen is conitunually subtracted
  814 0000031A D302            BLO              Endwhile    ;by the Divider until Dividen is either 0 or less than
  815 0000031C         ;the Divider... R2 is used as the quotient



ARM Macro Assembler    Page 22 


  816 0000031C 1A09            SUBS             R1,R1,R0
  817 0000031E 1C52            ADDS             R2,R2,#1
  818 00000320         
  819 00000320 E7FA            B                While
  820 00000322         Endwhile
  821 00000322 0010            MOVS             R0,R2
  822 00000324         
  823 00000324         
  824 00000324 BC04    DIVU_DONE
                               POP              {R2}        ;DIVU_DONE used when needed to return out of DIVU subroutine
                                                            
  825 00000326         
  826 00000326 4770            BX               LR
  827 00000328         
  828 00000328         
  829 00000328 F3EF 8000 
                       DIV_BY_ZERO
                               MRS              R0,APSR     ;Divide by zeros manually sets C flag to set
  830 0000032C 2120            MOVS             R1,#0x20
  831 0000032E 0609            LSLS             R1,R1,#24
  832 00000330 4308            ORRS             R0,R0,R1
  833 00000332 F380 8800       MSR              APSR,R0
  834 00000336 E7F5            B                DIVU_DONE
  835 00000338         
  836 00000338         
  837 00000338 F3EF 8000 
                       EndIFF  MRS              R0,APSR     ;EndIFF manually sets C flag to clear if dividend is 0
  838 0000033C 2020            MOVS             R0,#0x20
  839 0000033E 0609            LSLS             R1,R1,#24
  840 00000340 4388            BICS             R0,R0,R1
  841 00000342 F380 8800       MSR              APSR,R0
  842 00000346 2000            MOVS             R0,#0
  843 00000348         
  844 00000348 E7EC            B                DIVU_DONE
  845 0000034A         
  846 0000034A         
  847 0000034A         ;------------------------------------- INIT --------------------------------
  848 0000034A         ;initializes the UART_IRQ
  849 0000034A         ;code taken from lecture
  850 0000034A         ;shown in chunks
  851 0000034A         Init_UART0_IRQ
  852 0000034A B50E            PUSH             { R1, R2, R3, LR}



ARM Macro Assembler    Page 23 


  853 0000034C         ;Select MCGPLLCLK / 2 as UART0 clock source
  854 0000034C 484D            LDR              R0,=SIM_SOPT2
  855 0000034E 494E            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  856 00000350 6802            LDR              R2,[R0,#0]
  857 00000352 438A            BICS             R2,R2,R1
  858 00000354 494D            LDR              R1,=SIM_SOPT2_UART0_MCGPLLCLK_DIV2
  859 00000356 430A            ORRS             R2,R2,R1
  860 00000358 6002            STR              R2,[R0,#0]
  861 0000035A         ;Enable external connection for UART0
  862 0000035A 484D            LDR              R0,=SIM_SOPT5
  863 0000035C 494D            LDR              R1,= SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
  864 0000035E 6802            LDR              R2,[R0,#0]
  865 00000360 438A            BICS             R2,R2,R1
  866 00000362 6002            STR              R2,[R0,#0]
  867 00000364         ;Enable clock for UART0 module
  868 00000364 484C            LDR              R0,=SIM_SCGC4
  869 00000366 494D            LDR              R1,= SIM_SCGC4_UART0_MASK
  870 00000368 6802            LDR              R2,[R0,#0]
  871 0000036A 430A            ORRS             R2,R2,R1
  872 0000036C 6002            STR              R2,[R0,#0]
  873 0000036E         ;Enable clock for Port A module
  874 0000036E 484C            LDR              R0,=SIM_SCGC5
  875 00000370 494C            LDR              R1,= SIM_SCGC5_PORTA_MASK
  876 00000372 6802            LDR              R2,[R0,#0]
  877 00000374 430A            ORRS             R2,R2,R1
  878 00000376 6002            STR              R2,[R0,#0]
  879 00000378         ;Connect PORT A Pin 1 (PTA1) to UART0 Rx (J1 Pin 02)
  880 00000378 484B            LDR              R0,=PORTA_PCR1
  881 0000037A 494C            LDR              R1,=PORT_PCR_SET_PTA1_UART0_RX
  882 0000037C 6001            STR              R1,[R0,#0]
  883 0000037E         ;Connect PORT A Pin 2 (PTA2) to UART0 Tx (J1 Pin 04)
  884 0000037E 484C            LDR              R0,=PORTA_PCR2
  885 00000380 494A            LDR              R1,=PORT_PCR_SET_PTA2_UART0_TX
  886 00000382 6001            STR              R1,[R0,#0]
  887 00000384         
  888 00000384         
  889 00000384         ;Disable UART0 receiver and transmitter
  890 00000384 484B            LDR              R0,=UART0_BASE
  891 00000386 210C            MOVS             R1,#UART0_C2_T_R
  892 00000388 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  893 0000038A 438A            BICS             R2,R2,R1
  894 0000038C 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]



ARM Macro Assembler    Page 24 


  895 0000038E         ;Set UART0 for 9600 baud, 8N1 protocol
  896 0000038E 2101            MOVS             R1,#UART0_BDH_9600
  897 00000390 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  898 00000392 2138            MOVS             R1,#UART0_BDL_9600
  899 00000394 7041            STRB             R1,[R0,#UART0_BDL_OFFSET] ;Somethign on here
  900 00000396 2100            MOVS             R1,#UART0_C1_8N1
  901 00000398 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  902 0000039A 2100            MOVS             R1,#UART0_C3_NO_TXINV
  903 0000039C 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  904 0000039E 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  905 000003A0 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  906 000003A2 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  907 000003A4 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  908 000003A6 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  909 000003A8 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  911 000003AA 21C0            MOVS             R1,    #UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
  912 000003AC 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  913 000003AE         ;Enable UART0 receiver and transmitter
  914 000003AE 212C            MOVS             R1,#UART0_C2_T_RI
  915 000003B0 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  916 000003B2         
  917 000003B2 482E            LDR              R0,=RxQBuffer
  918 000003B4 492E            LDR              R1,=RxQRecord
  919 000003B6 2250            MOVS             R2,#TRxQ_BUF_SZ
  920 000003B8 F7FF FEEC       BL               InitQueue
  921 000003BC         
  922 000003BC 482D            LDR              R0,=TxQBuffer
  923 000003BE 492E            LDR              R1,=TxQRecord
  924 000003C0 2250            MOVS             R2,#TRxQ_BUF_SZ
  925 000003C2 F7FF FEE7       BL               InitQueue
  926 000003C6         
  927 000003C6         ;added for prelab 9
  928 000003C6         ;Set UART IRQ Priority
  929 000003C6 4840            LDR              R0,=UART0_IPR
  930 000003C8 4A40            LDR              R2,=NVIC_IPR_UART0_PRI_3
  931 000003CA 6803            LDR              R3,[R0,#0]
  932 000003CC 4313            ORRS             R3,R3,R2
  933 000003CE 6003            STR              R3,[R0,#0]
  934 000003D0         
  935 000003D0         ;clearing pending uart0Interrupts
  936 000003D0 483F            LDR              R0,=NVIC_ICPR
  937 000003D2 4940            LDR              R1,=NVIC_ICPR_UART0_MASK



ARM Macro Assembler    Page 25 


  938 000003D4 6001            STR              R1,[R0,#0]
  939 000003D6         
  940 000003D6         ;unmaks UART0 interrupts
  941 000003D6 4840            LDR              R0,=NVIC_ISER
  942 000003D8 493E            LDR              R1,=NVIC_ISER_UART0_MASK
  943 000003DA 6001            STR              R1,[R0,#0]
  944 000003DC         
  945 000003DC         
  946 000003DC BD0E            POP              { R1, R2, R3, PC}
  947 000003DE         
  948 000003DE         ;-----------------------------------UART0-ISR---------------------------------
  949 000003DE         ;the interrupt handler that is called by the vector table
  950 000003DE         UART0_ISR
  951 000003DE B672            CPSID            I
  952 000003E0 B5E0            PUSH             {R5-R7, LR}
  953 000003E2         
  954 000003E2 4A34            LDR              R2,=UART0_BASE ;recives the base
  955 000003E4 78D1            LDRB             R1,[R2,#UART0_C2_OFFSET]
  956 000003E6 2080            MOVS             R0,#UART0_C2_TIE_MASK ;masking
  957 000003E8         
  958 000003E8 4208            TST              R0,R1       ;testing the value in the offset verses the 
  959 000003EA         ;tie mask
  960 000003EA D00B            BEQ              RxInterrupt ;if they equal, then its confimed a Rx interrupt and brankes
                                                            
  961 000003EC 7911            LDRB             R1,[R2,#UART0_S1_OFFSET]
  962 000003EE 2080            MOVS             R0,#UART0_S1_TDRE_MASK ;TDRE mask
  963 000003F0         
  964 000003F0 4208            TST              R0,R1       ;checks again
  965 000003F2         
  966 000003F2 D007            BEQ              RxInterrupt ;if they equal, then its confimed a Rx interrupt and brankes
                                                            
  967 000003F4         
  968 000003F4 4920            LDR              R1,=TxQRecord ;if code has lasted this far, then TxQRecord is loaded
  969 000003F6         
  970 000003F6 F7FF FED7       BL               DeQueue     ;dequeues
  971 000003FA         
  972 000003FA D201            BCS              Else_01     ;if it fails, initiate else
  973 000003FC         
  974 000003FC 71D0            STRB             R0,[R2,#UART0_D_OFFSET]
  975 000003FE E001            B                RxInterrupt ;goes to RxInterrupt since it has failed
  976 00000400         
  977 00000400         



ARM Macro Assembler    Page 26 


  978 00000400         Else_01                              ;else loop that branches
  979 00000400 212C            MOVS             R1,#UART0_C2_T_RI
  980 00000402 70D1            STRB             R1,[R2,#UART0_C2_OFFSET]
  981 00000404         
  982 00000404         RxInterrupt                          ;Rxinterupt, which is called if it is confimred to be a Rx c
                                                            ase
  983 00000404         
  984 00000404 7911            LDRB             R1,[R2,#UART0_S1_OFFSET]
  985 00000406 2020            MOVS             R0,#UART0_S1_RDRF_MASK ;masking and so forth
  986 00000408         
  987 00000408 4208            TST              R0,R1
  988 0000040A         
  989 0000040A D003            BEQ              Over_ISR
  990 0000040C         
  991 0000040C 79D0            LDRB             R0,[R2,#UART0_D_OFFSET]
  992 0000040E 4918            LDR              R1,=RxQRecord ;loading RxQrecord and then enquing
  993 00000410 F7FF FEED       BL               Enqueue
  994 00000414         
  995 00000414         Over_ISR
  996 00000414         
  997 00000414 B662            CPSIE            I           ;stop masking
  998 00000416 BDE0            POP              {R5-R7,PC}
  999 00000418         
 1000 00000418         
 1001 00000418         ;--------------------------- PUTCHAR -----------------------
 1002 00000418         ;Recives R0
 1003 00000418         ;Places it onto termianl screen
 1004 00000418         ;does not modify registers
 1005 00000418         PutChar
 1006 00000418 B50F            PUSH             { R0, R1, R2, R3, LR }
 1007 0000041A 4917            LDR              R1,=TxQRecord ;loading TxQBuffer
 1008 0000041C         PC_Loop
 1009 0000041C B672            CPSID            I
 1010 0000041E F7FF FEE6       BL               Enqueue     ;enquing item in R0
 1011 00000422 B662            CPSIE            I
 1012 00000424 D2FA            BCS              PC_Loop
 1013 00000426         
 1014 00000426 4823            LDR              R0,=UART0_BASE
 1015 00000428 21AC            MOVS             R1,#UART0_C2_TI_RI
 1016 0000042A 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
 1017 0000042C         
 1018 0000042C BD0F            POP              { R0, R1, R2, R3, PC }



ARM Macro Assembler    Page 27 


 1019 0000042E         
 1020 0000042E         
 1021 0000042E         ;--------------------------- GETCHAR -----------------------
 1022 0000042E         ;takes terminal off of screen that has been entered
 1023 0000042E         ;places value into R0 register
 1024 0000042E         GetChar                              ;copy and paste code of Getchar
 1025 0000042E B50E            PUSH             { R1, R2, R3, LR }
 1026 00000430 490F            LDR              R1,=RxQRecord ;loading RxQBuff
 1027 00000432         GC_Loop
 1028 00000432 B672            CPSID            I
 1029 00000434 F7FF FEB8       BL               DeQueue     ;dequeuing from the queue
 1030 00000438 B662            CPSIE            I
 1031 0000043A         
 1032 0000043A D2FA            BCS              GC_Loop
 1033 0000043C         
 1034 0000043C BD0E            POP              { R1, R2, R3, PC }
 1035 0000043E         
 1036 0000043E         
 1037 0000043E         ;>>>>>   end subroutine code <<<<<
 1038 0000043E 00 00           ALIGN
 1039 00000440         ;****************************************************************
 1040 00000440         ;Vector Table Mapped to Address 0 at Reset
 1041 00000440         ;Linker requires __Vectors to be exported
 1042 00000440 00000000 
              00000000 
              00000000 
              0000004F 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              40048004 
              0C000000 



ARM Macro Assembler    Page 28 


              04010000 
              40048010 
              00010007 
              40048034 
              00000400 
              40048038 
              00000200 
              40049004 
              01000200 
              40049008 
              4006A000 
              00000000 
              00000000 
              00000000 
              00000000 
              E000E40C 
              000000C0 
              E000E280 
              00001000 
              E000E100 
              00000000 
              00000000 
              00000000 
              00000000         AREA             RESET, DATA, READONLY
 1043 00000000                 EXPORT           __Vectors
 1044 00000000                 EXPORT           __Vectors_End
 1045 00000000                 EXPORT           __Vectors_Size
 1046 00000000                 IMPORT           __initial_sp
 1047 00000000                 IMPORT           Dummy_Handler
 1048 00000000         __Vectors
 1049 00000000         ;ARM core vectors
 1050 00000000 00000000        DCD              __initial_sp ;00:end of stack
 1051 00000004 00000000        DCD              Reset_Handler ;01:reset vector
 1052 00000008 00000000        DCD              Dummy_Handler ;02:NMI
 1053 0000000C 00000000        DCD              Dummy_Handler ;03:hard fault
 1054 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
 1055 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
 1056 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
 1057 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
 1058 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
 1059 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
 1060 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)



ARM Macro Assembler    Page 29 


 1061 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (supervisor call)
 1062 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
 1063 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
 1064 00000038 00000000        DCD              Dummy_Handler ;14:PendableSrvReq (pendable request 
 1065 0000003C         ;   for system service)
 1066 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (system tick timer)
 1067 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0 xfer complete/error
 1068 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1 xfer complete/error
 1069 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2 xfer complete/error
 1070 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3 xfer complete/error
 1071 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
 1072 00000054 00000000        DCD              Dummy_Handler ;21:command complete; read collision
 1073 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage detect;
 1074 0000005C         ;   low-voltage warning
 1075 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage wakeup
 1076 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
 1077 00000064 00000000        DCD              Dummy_Handler ;25:I2C1
 1078 00000068 00000000        DCD              Dummy_Handler ;26:SPI0 (all IRQ sources)
 1079 0000006C 00000000        DCD              Dummy_Handler ;27:SPI1 (all IRQ sources)
 1080 00000070 00000000        DCD              UART0_ISR   ;28:UART0 (status; error)
 1081 00000074 00000000        DCD              Dummy_Handler ;29:UART1 (status; error)
 1082 00000078 00000000        DCD              Dummy_Handler ;30:UART2 (status; error)
 1083 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
 1084 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
 1085 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
 1086 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
 1087 0000008C 00000000        DCD              Dummy_Handler ;35:TPM2
 1088 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
 1089 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
 1090 00000098 00000000        DCD              Dummy_Handler ;38:PIT (all IRQ sources)
 1091 0000009C 00000000        DCD              Dummy_Handler ;39:I2S0
 1092 000000A0 00000000        DCD              Dummy_Handler ;40:USB0
 1093 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
 1094 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
 1095 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
 1096 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
 1097 000000B4 00000000        DCD              Dummy_Handler ;45:Segment LCD
 1098 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA pin detect
 1099 000000BC 00000000        DCD              Dummy_Handler ;47:PORTC and PORTD pin detect
 1100 000000C0         
 1101 000000C0         
 1102 000000C0         



ARM Macro Assembler    Page 30 


 1103 000000C0         __Vectors_End
 1104 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
 1105 000000C0                 ALIGN
 1106 000000C0         ;****************************************************************
 1107 000000C0         ;Constants
 1108 000000C0                 AREA             MyConst,DATA,READONLY
 1109 00000000         ;>>>>> begin constants here <<<<<
 1110 00000000 54 79 70 
              65 20 61 
              20 63 6F 
              6D 6D 61 
              6E 64 20 
              28 65 2C 
              64 2C 68 
              2C 70 2C 
              73 29 3A 
              20 00    InitString
                               DCB              "Type a command (e,d,h,p,s): ",0
 1111 0000001D         
 1112 0000001D 46 61 69 
              6C 75 72 
              65 3A 20 
              00       Failure DCB              "Failure: ",0
 1113 00000027         
 1114 00000027 53 75 63 
              63 65 73 
              73 3A 20 
              00       Success DCB              "Success: ",0
 1115 00000031         
 1116 00000031 49 6E 3D 
              30 78 00 Ln      DCB              "In=0x",0
 1117 00000037         
 1118 00000037 53 74 61 
              74 75 73 
              3A 00    Status  DCB              "Status:",0
 1119 0000003F         
 1120 0000003F 64 20 28 
              64 65 71 
              75 65 75 
              65 29 2C 



ARM Macro Assembler    Page 31 


              20 65 20 
              28 65 6E 
              71 75 65 
              75 65 29 
              2C 20 68 
              20 28 68 
              65 6C 70 
              29 2C 20 
              70 20 28 
              70 72 69 
              6E 74 29 
              2C 20 73 
              20 28 73 
              74 61 74 
              75 73 29 
              00       Help    DCB              "d (dequeue), e (enqueue), h (help), p (print), s (status)",0
 1121 00000079         
 1122 00000079 20 4F 75 
              74 3D 30 
              78 00    OUT     DCB              " Out=0x",0
 1123 00000081         
 1124 00000081 4C 65 6E 
              67 74 68 
              3A 00    Length  DCB              "Length:",0
 1125 00000089         
 1126 00000089 20 4E 75 
              6D 3D 00 Num     DCB              " Num=",0
 1127 0000008F         
 1128 0000008F 43 68 61 
              72 61 63 
              74 65 72 
              20 74 6F 
              20 65 6E 
              71 75 65 
              75 65 3A 
              00       CTE     DCB              "Character to enqueue:",0
 1129 000000A5         
 1130 000000A5 3A 20 20 
              20 20 20 
              20 20 20 
              00       DQGDS   DCB              ":        ",0
 1131 000000AF         ;>>>>>   end constants here <<<<<



ARM Macro Assembler    Page 32 


 1132 000000AF 00              ALIGN
 1133 000000B0         ;****************************************************************
 1134 000000B0         ;Variables
 1135 000000B0                 AREA             MyData,DATA,READWRITE
 1136 00000000         ;>>>>> begin variables here <<<<<
 1137 00000000         
 1138 00000000         
 1139 00000000 00 00 00 
              00       QBuffer SPACE            Q_BUF_SZ
 1140 00000004                 ALIGN
 1141 00000004 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 QRecord SPACE            Q_REC_SZ
 1142 00000016 00 00           ALIGN
 1143 00000018         
 1144 00000018         
 1145 00000018 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 33 


              00 00 00 
              00 00 00 
              00 00 00 
              00 00    RxQBuffer
                               SPACE            TRxQ_BUF_SZ
 1146 00000068                 ALIGN
 1147 00000068 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 RxQRecord
                               SPACE            Q_REC_SZ
 1148 0000007A 00 00           ALIGN
 1149 0000007C         
 1150 0000007C         
 1151 0000007C 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 34 


              00 00    TxQBuffer
                               SPACE            TRxQ_BUF_SZ
 1152 000000CC                 ALIGN
 1153 000000CC 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 TxQRecord
                               SPACE            Q_REC_SZ
 1154 000000DE 00 00           ALIGN
 1155 000000E0         
 1156 000000E0 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00       String  SPACE            79
 1157 0000012F         ;>>>>>   end variables here <<<<<
 1158 0000012F 00              ALIGN
 1159 00000130                 END



ARM Macro Assembler    Page 35 


Command Line: --debug --length=49 --width=120 --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --depend=".\objects
\exercise 09.d" -o".\objects\exercise 09.o" -I"D:\Assembly\Exercise 09\Code 09\RTE" -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_K
Lxx_DFP\1.6.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include --predefine="__UVISION_VERSION SETA 515" --predefine="MKL46Z
256xxx4 SETA 1" --list=.\listings\exercise 09.lst "Exercise 09.s"
