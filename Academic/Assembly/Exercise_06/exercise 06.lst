


ARM Macro Assembler    Page 1 


    1 00000000         ;Exercise 06
    2 00000000         ;****************************************************************
    3 00000000         ;Exercies 5 which is usesd to demonstrate chrypotographic
    4 00000000         ;and decifering techniques
    5 00000000         ;Name:  Joel Yuhas
    6 00000000         ;Date:  3/10/2016
    7 00000000         ;Class:  CMPE-250
    8 00000000         ;Section:  Lab section 2 2:00pm to 3:50pm
    9 00000000         ;---------------------------------------------------------------
   10 00000000         ;Keil Template for KL46
   11 00000000         ;R. W. Melton
   12 00000000         ;April 3, 2015
   13 00000000         ;****************************************************************
   14 00000000         ;Assembler directives
   15 00000000                 THUMB
   17 00000000         ;****************************************************************
   18 00000000         ;Include files
   19 00000000                 GET              MKL46Z4.s   ;Included by start.s
   21 00000000         ;****************************************************************
   22 00000000         ;EQUates
   23 00000000         ;---------------------------------------------------------------
   24 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   25 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   26 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   27 00000000         ;---------------------------------------------------------------
   28 00000000         ;Port A
   30 00000000 01000200 
                       PORT_PCR_SET_PTA1_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   32 00000000 01000200 
                       PORT_PCR_SET_PTA2_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   33 00000000         ;---------------------------------------------------------------
   34 00000000         ;SIM_SCGC4
   35 00000000         ;1->10:UART0 clock gate control (enabled)
   36 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   37 00000000         ;---------------------------------------------------------------
   38 00000000         ;SIM_SCGC5
   39 00000000         ;1->09:Port A clock gate control (enabled)
   40 00000000         ;Use provided SIM_SCGC5_PORTA_MASK



ARM Macro Assembler    Page 2 


   41 00000000         ;---------------------------------------------------------------
   42 00000000         ;SIM_SOPT2
   43 00000000         ;01=27-26:UART0SRC=UART0 clock source select
   44 00000000         ;         (PLLFLLSEL determines MCGFLLCLK' or MCGPLLCLK/2)
   45 00000000         ; 1=   16:PLLFLLSEL=PLL/FLL clock select (MCGPLLCLK/2)
   47 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGPLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
   49 00000000 04010000 
                       SIM_SOPT2_UART0_MCGPLLCLK_DIV2
                               EQU              (SIM_SOPT2_UART0SRC_MCGPLLCLK :OR: SIM_SOPT2_PLLFLLSEL_MASK)
   50 00000000         ;---------------------------------------------------------------
   51 00000000         ;SIM_SOPT5
   52 00000000         ; 0->   16:UART0 open drain enable (disabled)
   53 00000000         ; 0->   02:UART0 receive data select (UART0_RX)
   54 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
   58 00000000 00010007 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:                                  SIM_SOPT
5_UART0RXSRC_MASK :OR:                                  SIM_SOPT5_UART0TXSRC_MASK)
   59 00000000         ;---------------------------------------------------------------
   60 00000000         ;UART0_BDH
   61 00000000         ;    0->  7:LIN break detect IE (disabled)
   62 00000000         ;    0->  6:RxD input active edge IE (disabled)
   63 00000000         ;    0->  5:Stop bit number select (1)
   64 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
   65 00000000         ;UART0CLK is MCGPLLCLK/2
   66 00000000         ;MCGPLLCLK is 96 MHz
   67 00000000         ;MCGPLLCLK/2 is 48 MHz
   68 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   69 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
   70 00000000         ;---------------------------------------------------------------
   71 00000000         ;UART0_BDL
   72 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
   73 00000000         ;UART0CLK is MCGPLLCLK/2
   74 00000000         ;MCGPLLCLK is 96 MHz
   75 00000000         ;MCGPLLCLK/2 is 48 MHz
   76 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   77 00000000 00000038 
                       UART0_BDL_9600



ARM Macro Assembler    Page 3 


                               EQU              0x38
   78 00000000         ;---------------------------------------------------------------
   79 00000000         ;UART0_C1
   80 00000000         ;0-->7:LOOPS=loops select (normal)
   81 00000000         ;0-->6:DOZEEN=doze enable (disabled)
   82 00000000         ;0-->5:RSRC=receiver source select (internal--no effect LOOPS=0)
   83 00000000         ;0-->4:M=9- or 8-bit mode select 
   84 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
   85 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
   86 00000000         ;0-->2:IDLE=idle line type select (idle begins after start bit)
   87 00000000         ;0-->1:PE=parity enable (disabled)
   88 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
   89 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
   90 00000000         ;---------------------------------------------------------------
   91 00000000         ;UART0_C2
   92 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
   93 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
   94 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
   95 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
   96 00000000         ;1-->3:TE=transmitter enable (enabled)
   97 00000000         ;1-->2:RE=receiver enable (enabled)
   98 00000000         ;0-->1:RWU=receiver wakeup control (normal)
   99 00000000         ;0-->0:SBK=send break (disabled, normal)
  100 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2_RE_MASK)
  101 00000000         ;---------------------------------------------------------------
  102 00000000         ;UART0_C3
  103 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  104 00000000         ;           10th data bit for transmitter (not used M10=0)
  105 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  106 00000000         ;           10th data bit for receiver (not used M10=0)
  107 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  108 00000000         ;            (no effect LOOPS=0)
  109 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  110 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  111 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  112 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  113 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  114 00000000 00000000 



ARM Macro Assembler    Page 4 


                       UART0_C3_NO_TXINV
                               EQU              0x00
  115 00000000         ;---------------------------------------------------------------
  116 00000000         ;UART0_C4
  117 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled)
  118 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled)
  119 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  120 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  121 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  122 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  123 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  124 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  125 00000000         ;---------------------------------------------------------------
  126 00000000         ;UART0_C5
  127 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  128 00000000         ;  0-->  6:Reserved; read-only; always 0
  129 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)
  130 00000000         ;000-->4-2:Reserved; read-only; always 0
  131 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only)
  132 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
  133 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  134 00000000         ;---------------------------------------------------------------
  135 00000000         ;UART0_S1
  136 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
  137 00000000         ;0-->6:TC=transmission complete flag; read-only
  138 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  139 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  140 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear)
  141 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  142 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  143 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  144 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              0x1F
  145 00000000         ;---------------------------------------------------------------
  146 00000000         ;UART0_S2



ARM Macro Assembler    Page 5 


  147 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  148 00000000         ;             write 1 to clear
  149 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear)
  150 00000000         ;              write 1 to clear
  151 00000000         ;0-->5:(reserved); read-only; always 0
  152 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  153 00000000         ;0-->3:RWUID=receive wake-up idle detect
  154 00000000         ;0-->2:BRK13=break character generation length (10)
  155 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  156 00000000         ;0-->0:RAF=receiver active flag; read-only
  157 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              0xC0
  158 00000000         ;--------------------------------------------------------------
  159 00000000 0000000D 
                       CR      EQU              0x0D
  160 00000000 0000000A 
                       LF      EQU              0x0A
  161 00000000 0000004F 
                       MAX_STRING
                               EQU              79
  162 00000000         ;****************************************************************
  163 00000000         ;Program
  164 00000000         ;Linker requires Reset_Handler
  165 00000000                 AREA             MyCode,CODE,READONLY
  166 00000000                 ENTRY
  167 00000000                 EXPORT           Reset_Handler
  168 00000000                 IMPORT           Startup
  169 00000000         Reset_Handler
  170 00000000         main
  171 00000000         ;---------------------------------------------------------------
  172 00000000         ;Mask interrupts
  173 00000000 B672            CPSID            I
  174 00000002         ;KL46 system startup with 48-MHz system clock
  175 00000002 F7FF FFFE       BL               Startup
  176 00000006         ;---------------------------------------------------------------
  177 00000006         ;---------------------- HEADER -------------------------
  178 00000006         ;Program outputs initial string, waits for user input
  179 00000006         ;then, depending on specified input, will call specific
  180 00000006         ;subroutines
  181 00000006         ;
  182 00000006         ;these subroutines include but are not limited to



ARM Macro Assembler    Page 6 


  183 00000006         ;----------GetStringSB
  184 00000006         ;----------LengthStringSB
  185 00000006         ;----------PutStringSB
  186 00000006         ;----------PutNumU
  187 00000006         ;----------PutChar
  188 00000006         ;----------GetChar
  189 00000006         ;
  190 00000006         ;the program also used registers R0-R5, R7, PC, LR
  191 00000006         ;the program is continually running until manually ended
  192 00000006         ;as it waits for user input
  193 00000006         
  194 00000006         
  195 00000006         ;>>>>> begin main program code <<<<<
  196 00000006         
  197 00000006 488C            LDR              R0,=String
  198 00000008 2100            MOVS             R1,#0
  199 0000000A 7001            STRB             R1,[R0,#0]
  200 0000000C F000 F864       BL               Init        ;initializing UART0
  201 00000010         Loop                                 ;infinite loop 
  202 00000010         
  203 00000010 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  204 00000012 488A            LDR              R0,=InitString ;loading the initial output of "Type a string command (g,
                                                            i,l,p):"
  205 00000014 F000 F8E3       BL               PutStringSB
  206 00000018         
  207 00000018 F000 F89D       BL               GetChar     ;getting the first user input
  208 0000001C 285A            CMP              R0, #'Z'    ;checking to see if upper case
  209 0000001E 4607            MOV              R7,R0       ;saving the original value for later
  210 00000020 D94B            BLS              UpperCase   ;if it is uppercase, branch and fix it
  211 00000022         
  212 00000022         Back                                 ;back from uppercase fix
  213 00000022 2867            CMP              R0, #'g'    ;checking if 'g'
  214 00000024 D007            BEQ              CorrectG
  215 00000026 2869            CMP              R0, #'i'    ;checking if 'i'
  216 00000028 D015            BEQ              CorrectI
  217 0000002A 286C            CMP              R0, #'l'    ;checking if 'l'
  218 0000002C D01F            BEQ              CorrectL
  219 0000002E 2870            CMP              R0, #'p'    ;checking if 'p'
  220 00000030 D030            BEQ              CorrectP
  221 00000032         
  222 00000032         
  223 00000032 E7ED            B                Loop        ;looping forever



ARM Macro Assembler    Page 7 


  224 00000034         
  225 00000034         
  226 00000034         
  227 00000034         
  228 00000034         ;>>>>>   end main program code <<<<<
  229 00000034         ;Stay here
  230 00000034 E7FE            B                .
  231 00000036         
  232 00000036         ;>>>>> begin subroutine code <<<<<
  233 00000036         ;----------------------- G ----------------------------
  234 00000036         CorrectG
  235 00000036 F000 F844       BL               Correct     ;Base correct subroutine that sets up subroutines
  236 0000003A 203C            MOVS             R0,#'<'     ;printing '>'
  237 0000003C F000 F882       BL               PutChar
  238 00000040 487D            LDR              R0,=String  ;loads string
  239 00000042 214F            MOVS             R1,#MAX_STRING ;loads buffer capacity
  240 00000044 F000 F890       BL               GetStringSB ;calls GetStringSB
  241 00000048         
  242 00000048 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  243 0000004A F000 F87B       BL               PutChar
  244 0000004E 200A            MOVS             R0,#LF
  245 00000050 F000 F878       BL               PutChar
  246 00000054         
  247 00000054 E7DC            B                Loop
  248 00000056         
  249 00000056         
  250 00000056         ;----------------------- I ----------------------------
  251 00000056         CorrectI
  252 00000056 F000 F834       BL               Correct     ;Base correct subroutine that sets up subroutines
  253 0000005A 2100            MOVS             R1,#0       ;making a zero
  254 0000005C 4876            LDR              R0,=String  ;loading string
  255 0000005E 7001            STRB             R1,[R0,#0]  ;killing everyone String ever loved and replacing it with 0
  256 00000060         
  257 00000060 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  258 00000062 F000 F86F       BL               PutChar
  259 00000066 200A            MOVS             R0,#LF
  260 00000068 F000 F86C       BL               PutChar
  261 0000006C         
  262 0000006C E7D0            B                Loop
  263 0000006E         
  264 0000006E         
  265 0000006E         ;----------------------- L ----------------------------



ARM Macro Assembler    Page 8 


  266 0000006E         CorrectL
  267 0000006E F000 F828       BL               Correct     ;Base correct subroutine that sets up subroutines
  268 00000072 4871            LDR              R0,=String  ;loading string
  269 00000074 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  270 00000076 F000 F894       BL               LengthStringSB ;calling LengthStringSB
  271 0000007A         
  272 0000007A 4871            LDR              R0,=Length  ;loading length string "length: "
  273 0000007C F000 F8AF       BL               PutStringSB ;printing it
  274 00000080         
  275 00000080 0010            MOVS             R0,R2       ;setting put PutNumU
  276 00000082 F000 F898       BL               PutNumU     ;calling PutNumU
  277 00000086         
  278 00000086 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  279 00000088 F000 F85C       BL               PutChar
  280 0000008C 200A            MOVS             R0,#LF
  281 0000008E F000 F859       BL               PutChar
  282 00000092         
  283 00000092 E7BD            B                Loop
  284 00000094         
  285 00000094         ;----------------------- P ----------------------------
  286 00000094         CorrectP
  287 00000094 F000 F815       BL               Correct     ;Base correct subroutine that sets up subroutines
  288 00000098 203E            MOVS             R0,#'>'     ;printing '>'
  289 0000009A F000 F853       BL               PutChar
  290 0000009E         
  291 0000009E 4866            LDR              R0,=String  ;loading string
  292 000000A0 214F            MOVS             R1,#MAX_STRING ;loading buffer cpacity 
  293 000000A2 F000 F89C       BL               PutStringSB ;printing string
  294 000000A6         
  295 000000A6 203E            MOVS             R0,#'>'     ;printing '>'
  296 000000A8 F000 F84C       BL               PutChar
  297 000000AC         
  298 000000AC 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  299 000000AE F000 F849       BL               PutChar
  300 000000B2 200A            MOVS             R0,#LF
  301 000000B4 F000 F846       BL               PutChar
  302 000000B8         
  303 000000B8 E7AA            B                Loop
  304 000000BA         
  305 000000BA         
  306 000000BA         ;----------------------- UpperCase ----------------------------
  307 000000BA         UpperCase



ARM Macro Assembler    Page 9 


  308 000000BA 0007            MOVS             R7,R0       ;saves initial value in R7
  309 000000BC 3020            ADDS             R0,R0,#32   ;converts to lower case
  310 000000BE F7FF FFB0       BL               Back
  311 000000C2         
  312 000000C2         Correct
  313 000000C2 B501            PUSH             {R0, LR}
  314 000000C4 0038            MOVS             R0,R7       ;printing original value
  315 000000C6 F000 F83D       BL               PutChar
  316 000000CA         
  317 000000CA 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  318 000000CC F000 F83A       BL               PutChar
  319 000000D0 200A            MOVS             R0,#LF
  320 000000D2 F000 F837       BL               PutChar
  321 000000D6 BD01            POP              {R0, PC}
  322 000000D8         
  323 000000D8         
  324 000000D8         
  325 000000D8         ;--------------------------- INIT -----------------------
  326 000000D8         Init                                 ;copy and paste code initializing UART0
  327 000000D8 B40E            PUSH             { R1, R2, R3}
  328 000000DA         ;Select MCGPLLCLK / 2 as UART0 clock source
  329 000000DA 485E            LDR              R0,=SIM_SOPT2
  330 000000DC 495E            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  331 000000DE 6802            LDR              R2,[R0,#0]
  332 000000E0 438A            BICS             R2,R2,R1
  333 000000E2 495E            LDR              R1,=SIM_SOPT2_UART0_MCGPLLCLK_DIV2
  334 000000E4 430A            ORRS             R2,R2,R1
  335 000000E6 6002            STR              R2,[R0,#0]
  336 000000E8         ;Enable external connection for UART0
  337 000000E8 485D            LDR              R0,=SIM_SOPT5
  338 000000EA 495E            LDR              R1,= SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
  339 000000EC 6802            LDR              R2,[R0,#0]
  340 000000EE 438A            BICS             R2,R2,R1
  341 000000F0 6002            STR              R2,[R0,#0]
  342 000000F2         ;Enable clock for UART0 module
  343 000000F2 485D            LDR              R0,=SIM_SCGC4
  344 000000F4 495D            LDR              R1,= SIM_SCGC4_UART0_MASK
  345 000000F6 6802            LDR              R2,[R0,#0]
  346 000000F8 430A            ORRS             R2,R2,R1
  347 000000FA 6002            STR              R2,[R0,#0]
  348 000000FC         ;Enable clock for Port A module
  349 000000FC 485C            LDR              R0,=SIM_SCGC5



ARM Macro Assembler    Page 10 


  350 000000FE 495D            LDR              R1,= SIM_SCGC5_PORTA_MASK
  351 00000100 6802            LDR              R2,[R0,#0]
  352 00000102 430A            ORRS             R2,R2,R1
  353 00000104 6002            STR              R2,[R0,#0]
  354 00000106         ;Connect PORT A Pin 1 (PTA1) to UART0 Rx (J1 Pin 02)
  355 00000106 485C            LDR              R0,=PORTA_PCR1
  356 00000108 495C            LDR              R1,=PORT_PCR_SET_PTA1_UART0_RX
  357 0000010A 6001            STR              R1,[R0,#0]
  358 0000010C         ;Connect PORT A Pin 2 (PTA2) to UART0 Tx (J1 Pin 04)
  359 0000010C 485C            LDR              R0,=PORTA_PCR2
  360 0000010E 495B            LDR              R1,=PORT_PCR_SET_PTA2_UART0_TX
  361 00000110 6001            STR              R1,[R0,#0]
  362 00000112         
  363 00000112         
  364 00000112         
  365 00000112         
  366 00000112         ;Disable UART0 receiver and transmitter
  367 00000112 485C            LDR              R0,=UART0_BASE
  368 00000114 210C            MOVS             R1,#UART0_C2_T_R
  369 00000116 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  370 00000118 438A            BICS             R2,R2,R1
  371 0000011A 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  372 0000011C         ;Set UART0 for 9600 baud, 8N1 protocol
  373 0000011C 2101            MOVS             R1,#UART0_BDH_9600
  374 0000011E 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  375 00000120 2138            MOVS             R1,#UART0_BDL_9600
  376 00000122 7041            STRB             R1,[R0,#UART0_BDL_OFFSET] ;Somethign on here
  377 00000124 2100            MOVS             R1,#UART0_C1_8N1
  378 00000126 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  379 00000128 2100            MOVS             R1,#UART0_C3_NO_TXINV
  380 0000012A 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  381 0000012C 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  382 0000012E 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  383 00000130 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  384 00000132 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  385 00000134 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  386 00000136 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  388 00000138 21C0            MOVS             R1,    #UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
  389 0000013A 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  390 0000013C         ;Enable UART0 receiver and transmitter
  391 0000013C 210C            MOVS             R1,#UART0_C2_T_R
  392 0000013E 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]



ARM Macro Assembler    Page 11 


  393 00000140         
  394 00000140 BC0E            POP              { R1, R2, R3}
  395 00000142         
  396 00000142 4770            BX               LR
  397 00000144         
  398 00000144         ;--------------------------- PUTCHAR -----------------------
  399 00000144         PutChar                              ;copy and paste code of Putchar
  400 00000144 B40E            PUSH             { R1, R2, R3 }
  401 00000146         ;Poll TDRE until UART0 ready to transmit
  402 00000146 494F            LDR              R1,=UART0_BASE
  403 00000148 2280            MOVS             R2,#UART0_S1_TDRE_MASK
  404 0000014A 790B    PollTx  LDRB             R3,[R1,#UART0_S1_OFFSET]
  405 0000014C 4013            ANDS             R3,R3,R2
  406 0000014E D0FC            BEQ              PollTx
  407 00000150         ;Transmit character stored in Ri
  408 00000150 71C8            STRB             R0,[R1,#UART0_D_OFFSET]
  409 00000152         
  410 00000152 BC0E            POP              { R1, R2, R3 }
  411 00000154         
  412 00000154 4770            BX               LR
  413 00000156         
  414 00000156         ;--------------------------- GETCHAR -----------------------
  415 00000156         GetChar                              ;copy and paste code of Getchar
  416 00000156 B40E            PUSH             { R1, R2, R3 }
  417 00000158         ;Poll RDRF until UART0 ready to receive
  418 00000158 494A            LDR              R1,=UART0_BASE
  419 0000015A 2220            MOVS             R2,#UART0_S1_RDRF_MASK
  420 0000015C 790B    PollRx  LDRB             R3,[R1,#UART0_S1_OFFSET]
  421 0000015E 4013            ANDS             R3,R3,R2
  422 00000160 D0FC            BEQ              PollRx
  423 00000162         ;Receive character and store in Ri
  424 00000162 79C8            LDRB             R0,[R1,#UART0_D_OFFSET]
  425 00000164 BC0E            POP              { R1, R2, R3 }
  426 00000166         
  427 00000166 4770            BX               LR
  428 00000168         
  429 00000168         
  430 00000168         
  431 00000168         ;--------------------------- GETSTRINGSB -----------------------  
  432 00000168         GetStringSB
  433 00000168 B51F            PUSH             { R0 - R4, LR }
  434 0000016A 2300            MOVS             R3,#0       ;initializing counter



ARM Macro Assembler    Page 12 


  435 0000016C 0004            MOVS             R4,R0       ;storing adress
  436 0000016E 1E49            SUBS             R1,R1,#1    ;subtracting buffer capacity
  437 00000170         
  438 00000170         Loop1A                               ;super loop
  439 00000170 F7FF FFF1       BL               GetChar     ;checking if input is "enter"
  440 00000174 280D            CMP              R0, #CR
  441 00000176 D00B            BEQ              Enter       ;branching if it is
  442 00000178         
  443 00000178         
  444 00000178 4299            CMP              R1,R3       ;checking if index = buffer cpacity
  445 0000017A D004            BEQ              Skip        ;if it is, skip
  446 0000017C 54E0            STRB             R0,[R4,R3]  ;otherwise store in adress with value (R0) at address (R4) o
                                                            ffset of increment (R3)
  447 0000017E 1C5B            ADDS             R3,R3,#1    ;incrementing counter
  448 00000180         
  449 00000180         
  450 00000180 F7FF FFE0       BL               PutChar     ;printing it
  451 00000184 E7F4            B                Loop1A      ;looping almost forever
  452 00000186         
  453 00000186         Skip
  454 00000186 F7FF FFE6       BL               GetChar     ;triggered if buffercapacity over limit and ignores everythi
                                                            ng until enter is hit
  455 0000018A 280D            CMP              R0, #CR
  456 0000018C D000            BEQ              Enter
  457 0000018E E7FA            B                Skip
  458 00000190         Enter                                ;if enter was hit
  459 00000190 2000            MOVS             R0,#0       ;storing '0' at end
  460 00000192 54E0            STRB             R0,[R4,R3]
  461 00000194 200D            MOVS             R0,#CR      ;printing new line
  462 00000196 F7FF FFD5       BL               PutChar
  463 0000019A 200A            MOVS             R0,#LF
  464 0000019C F7FF FFD2       BL               PutChar
  465 000001A0 BD1F            POP              { R0 - R4, PC }
  466 000001A2         
  467 000001A2         ;--------------------------- LENGTHSTRINGSB -----------------------  
  468 000001A2         LengthStringSB
  469 000001A2 B50A            PUSH             { R1, R3, LR }
  470 000001A4         
  471 000001A4 2200            MOVS             R2,#0       ;initializing counter
  472 000001A6         
  473 000001A6         Loop2
  474 000001A6 5C83            LDRB             R3,[R0,R2]  ;loading value in string



ARM Macro Assembler    Page 13 


  475 000001A8 2B00            CMP              R3,#0       ;checking if '0', if it is, run away
  476 000001AA D003            BEQ              Ende
  477 000001AC 428A            CMP              R2, R1      ;checking if counter = buffercapacity, if it does, run away
  478 000001AE D001            BEQ              Ende
  479 000001B0 1C52            ADDS             R2,R2, #1
  480 000001B2         
  481 000001B2 E7F8            B                Loop2       ;looping almost forver
  482 000001B4         Ende
  483 000001B4         
  484 000001B4 BD0A            POP              { R1, R3, PC }
  485 000001B6         
  486 000001B6         ;--------------------------- PUTNUMU -----------------------  
  487 000001B6         PutNumU
  488 000001B6 B507            PUSH             { R0 - R2, LR }
  489 000001B8 2200            MOVS             R2,#0       ;initializng counter
  490 000001BA         Loop3
  491 000001BA 0001            MOVS             R1, R0      ;setting up for DIVU (R1 divedend, R0 divider)
  492 000001BC 200A            MOVS             R0, #10
  493 000001BE F000 F81B       BL               DIVU        ;calling DIVU
  494 000001C2 B402            PUSH             {R1}        ;storing in stack because it gets values in revers order
  495 000001C4 1C52            ADDS             R2,R2,#1
  496 000001C6 2800            CMP              R0, #0      ;checking done
  497 000001C8 D000            BEQ              Out         ;if it is, end
  498 000001CA E7F6            B                Loop3
  499 000001CC         
  500 000001CC         Out
  501 000001CC BC01            POP              {R0}        ;finishing up
  502 000001CE 1E52            SUBS             R2,R2,#1
  503 000001D0 3030            ADDS             R0,R0,#'0'
  504 000001D2 F7FF FFB7       BL               PutChar
  505 000001D6 2A00            CMP              R2,#0
  506 000001D8 D000            BEQ              Done
  507 000001DA E7F7            B                Out
  508 000001DC         
  509 000001DC         Done
  510 000001DC BD07            POP              { R0 - R2, PC }
  511 000001DE         
  512 000001DE         
  513 000001DE         ;--------------------------- PUTSTRINGSB -----------------------
  514 000001DE         PutStringSB
  515 000001DE B50F            PUSH             { R0, R1, R2, R3, LR }
  516 000001E0         



ARM Macro Assembler    Page 14 


  517 000001E0 2300            MOVS             R3,#0       ;counter
  518 000001E2 0002            MOVS             R2,R0       ;R2 gets adress
  519 000001E4         
  520 000001E4         Loop4
  521 000001E4 428B            CMP              R3,R1       ;compares counter with MAX SIZE
  522 000001E6 D006            BEQ              Ende2
  523 000001E8         
  524 000001E8 5CD0            LDRB             R0,[R2,R3]  ;loads value at R2 offset R3 into R0
  525 000001EA 2800            CMP              R0,#0       ;checks if null terminator
  526 000001EC D003            BEQ              Ende2
  527 000001EE         
  528 000001EE F7FF FFA9       BL               PutChar     ;prints
  529 000001F2 1C5B            ADDS             R3,R3, #1   ;adds to counter
  530 000001F4         
  531 000001F4 E7F6            B                Loop4
  532 000001F6         Ende2
  533 000001F6         
  534 000001F6 BD0F            POP              { R0, R1, R2, R3, PC }
  535 000001F8         
  536 000001F8         
  537 000001F8         ;--------------------------- DIVU -----------------------
  538 000001F8         
  539 000001F8         DIVU
  540 000001F8         
  541 000001F8 B404            PUSH             {R2}        ;Pushing R2 to save
  542 000001FA 2200            MOVS             R2,#0
  543 000001FC 2800            CMP              R0,#0       ;checks if Divide by zero
  544 000001FE D009            BEQ              DIV_BY_ZERO
  545 00000200         
  546 00000200         
  547 00000200         
  548 00000200 2900            CMP              R1,#0       ;checks if Dividend is zero
  549 00000202 D00F            BEQ              EndIFF
  550 00000204         
  551 00000204 4281    While   CMP              R1,R0       ;the main loop where Dividen is conitunually subtracted
  552 00000206 D302            BLO              Endwhile    ;by the Divider until Dividen is either 0 or less than
  553 00000208         ;the Divider... R2 is used as the quotient
  554 00000208 1A09            SUBS             R1,R1,R0
  555 0000020A 1C52            ADDS             R2,R2,#1
  556 0000020C         
  557 0000020C E7FA            B                While
  558 0000020E         Endwhile



ARM Macro Assembler    Page 15 


  559 0000020E 0010            MOVS             R0,R2
  560 00000210         
  561 00000210         
  562 00000210         
  563 00000210         
  564 00000210         
  565 00000210 BC04    DIVU_DONE
                               POP              {R2}        ;DIVU_DONE used when needed to return out of DIVU subroutine
                                                            
  566 00000212         
  567 00000212 4770            BX               LR
  568 00000214         
  569 00000214         
  570 00000214 F3EF 8000 
                       DIV_BY_ZERO
                               MRS              R0,APSR     ;Divide by zeros manually sets C flag to set
  571 00000218 2120            MOVS             R1,#0x20
  572 0000021A 0609            LSLS             R1,R1,#24
  573 0000021C 4308            ORRS             R0,R0,R1
  574 0000021E F380 8800       MSR              APSR,R0
  575 00000222 E7F5            B                DIVU_DONE
  576 00000224         
  577 00000224         
  578 00000224 F3EF 8000 
                       EndIFF  MRS              R0,APSR     ;EndIFF manually sets C flag to clear if dividend is 0
  579 00000228 2020            MOVS             R0,#0x20
  580 0000022A 0609            LSLS             R1,R1,#24
  581 0000022C 4388            BICS             R0,R0,R1
  582 0000022E F380 8800       MSR              APSR,R0
  583 00000232 2000            MOVS             R0,#0
  584 00000234         
  585 00000234 E7EC            B                DIVU_DONE
  586 00000236         
  587 00000236         
  588 00000236         
  589 00000236         
  590 00000236         
  591 00000236         
  592 00000236         ;>>>>>   end subroutine code <<<<<
  593 00000236 00 00           ALIGN
  594 00000238         ;****************************************************************
  595 00000238         ;Vector Table Mapped to Address 0 at Reset



ARM Macro Assembler    Page 16 


  596 00000238         ;Linker requires __Vectors to be exported
  597 00000238 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              40048004 
              0C000000 
              04010000 
              40048010 
              00010007 
              40048034 
              00000400 
              40048038 
              00000200 
              40049004 
              01000200 
              40049008 
              4006A000         AREA             RESET, DATA, READONLY
  598 00000000                 EXPORT           __Vectors
  599 00000000                 EXPORT           __Vectors_End
  600 00000000                 EXPORT           __Vectors_Size
  601 00000000                 IMPORT           __initial_sp
  602 00000000                 IMPORT           Dummy_Handler
  603 00000000         __Vectors
  604 00000000         ;ARM core vectors
  605 00000000 00000000        DCD              __initial_sp ;00:end of stack
  606 00000004 00000000        DCD              Reset_Handler ;01:reset vector
  607 00000008 00000000        DCD              Dummy_Handler ;02:NMI
  608 0000000C 00000000        DCD              Dummy_Handler ;03:hard fault
  609 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
  610 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
  611 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
  612 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
  613 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
  614 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
  615 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
  616 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (supervisor call)
  617 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
  618 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)



ARM Macro Assembler    Page 17 


  619 00000038 00000000        DCD              Dummy_Handler ;14:PendableSrvReq (pendable request 
  620 0000003C         ;   for system service)
  621 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (system tick timer)
  622 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0 xfer complete/error
  623 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1 xfer complete/error
  624 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2 xfer complete/error
  625 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3 xfer complete/error
  626 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
  627 00000054 00000000        DCD              Dummy_Handler ;21:command complete; read collision
  628 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage detect;
  629 0000005C         ;   low-voltage warning
  630 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage wakeup
  631 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
  632 00000064 00000000        DCD              Dummy_Handler ;25:I2C1
  633 00000068 00000000        DCD              Dummy_Handler ;26:SPI0 (all IRQ sources)
  634 0000006C 00000000        DCD              Dummy_Handler ;27:SPI1 (all IRQ sources)
  635 00000070 00000000        DCD              Dummy_Handler ;28:UART0 (status; error)
  636 00000074 00000000        DCD              Dummy_Handler ;29:UART1 (status; error)
  637 00000078 00000000        DCD              Dummy_Handler ;30:UART2 (status; error)
  638 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
  639 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
  640 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
  641 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
  642 0000008C 00000000        DCD              Dummy_Handler ;35:TPM2
  643 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
  644 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
  645 00000098 00000000        DCD              Dummy_Handler ;38:PIT (all IRQ sources)
  646 0000009C 00000000        DCD              Dummy_Handler ;39:I2S0
  647 000000A0 00000000        DCD              Dummy_Handler ;40:USB0
  648 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
  649 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
  650 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
  651 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
  652 000000B4 00000000        DCD              Dummy_Handler ;45:Segment LCD
  653 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA pin detect
  654 000000BC 00000000        DCD              Dummy_Handler ;47:PORTC and PORTD pin detect
  655 000000C0         
  656 000000C0         
  657 000000C0         
  658 000000C0         __Vectors_End
  659 000000C0 000000C0 
                       __Vectors_Size



ARM Macro Assembler    Page 18 


                               EQU              __Vectors_End - __Vectors
  660 000000C0                 ALIGN
  661 000000C0         ;****************************************************************
  662 000000C0         ;Constants
  663 000000C0                 AREA             MyConst,DATA,READONLY
  664 00000000         ;>>>>> begin constants here <<<<<
  665 00000000 54 79 70 
              65 20 61 
              20 73 74 
              72 69 6E 
              67 20 63 
              6F 6D 6D 
              61 6E 64 
              20 28 47 
              2C 69 2C 
              6C 2C 70 
              29 3A 20 
              00       InitString
                               DCB              "Type a string command (G,i,l,p): ",0
  666 00000022         
  667 00000022 4C 65 6E 
              67 74 68 
              3A 00    Length  DCB              "Length:",0
  668 0000002A         ;>>>>>   end constants here <<<<<
  669 0000002A         
  670 0000002A         
  671 0000002A         
  679 0000002A         ;/                                ;/::                               ;/::::                 ;,
                       a_a         /\::::/                ;{/ ''\_      /\ \::/\                 ;{\ ,_oo)    /\ \ \/\
                        \                 ;{/  (_^____/  \ \ \ \ \       ;.=.      {/ \___)))*)    \ \ \ \ \/
  680 0000002A         ;(.=.`\   {/   /=;  ~/      \ \ \ \/
  681 0000002A         ;\ `\{/(   \/\  /        \ \ \/
  682 0000002A         ;\  `. `\  ) )           \ \/
  683 0000002A         ;\    // /_/_            \/
  684 0000002A         ;'==''---))))
  685 0000002A         
  686 0000002A         
  687 0000002A         
  688 0000002A         
  689 0000002A         
  690 0000002A         
  691 0000002A 00 00           ALIGN



ARM Macro Assembler    Page 19 


  692 0000002C         ;****************************************************************
  693 0000002C         ;Variables
  694 0000002C                 AREA             MyData,DATA,READWRITE
  695 00000000         ;>>>>> begin variables here <<<<<
  696 00000000 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00       String  SPACE            79
  697 0000004F         ;>>>>>   end variables here <<<<<
  698 0000004F 00              ALIGN
  699 00000050                 END
Command Line: --debug --length=49 --width=120 --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --depend=".\objects
\exercise 06.d" -o".\objects\exercise 06.o" -I"D:\Assembly\Exercise 06\Code 06\RTE" -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_K
Lxx_DFP\1.6.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include --predefine="__UVISION_VERSION SETA 515" --predefine="MKL46Z
256xxx4 SETA 1" --list=.\listings\exercise 06.lst "Exercise 06.s"
