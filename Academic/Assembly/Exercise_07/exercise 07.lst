


ARM Macro Assembler    Page 1 


    1 00000000         ;Exercise 06
    2 00000000         ;****************************************************************
    3 00000000         ;Exercies 5 which is usesd to demonstrate chrypotographic
    4 00000000         ;and decifering techniques
    5 00000000         ;Name:  Joel Yuhas
    6 00000000         ;Date:  3/10/2016
    7 00000000         ;Class:  CMPE-250
    8 00000000         ;Section:  Lab section 2 2:00pm to 3:50pm
    9 00000000         ;---------------------------------------------------------------
   10 00000000         ;Keil Template for KL46
   11 00000000         ;R. W. Melton
   12 00000000         ;April 3, 2015
   13 00000000         ;****************************************************************
   14 00000000         ;Assembler directives
   15 00000000                 THUMB
   17 00000000         ;****************************************************************
   18 00000000         ;Include files
   19 00000000                 GET              MKL46Z4.s   ;Included by start.s
   21 00000000         ;****************************************************************
   22 00000000         ;EQUates
   23 00000000         ;---------------------------------------------------------------
   24 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   25 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   26 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   27 00000000         ;---------------------------------------------------------------
   28 00000000         ;Port A
   30 00000000 01000200 
                       PORT_PCR_SET_PTA1_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   32 00000000 01000200 
                       PORT_PCR_SET_PTA2_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:                                    PORT_PCR_MUX
_SELECT_2_MASK)
   33 00000000         ;---------------------------------------------------------------
   34 00000000         ;SIM_SCGC4
   35 00000000         ;1->10:UART0 clock gate control (enabled)
   36 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   37 00000000         ;---------------------------------------------------------------
   38 00000000         ;SIM_SCGC5
   39 00000000         ;1->09:Port A clock gate control (enabled)
   40 00000000         ;Use provided SIM_SCGC5_PORTA_MASK



ARM Macro Assembler    Page 2 


   41 00000000         ;---------------------------------------------------------------
   42 00000000         ;SIM_SOPT2
   43 00000000         ;01=27-26:UART0SRC=UART0 clock source select
   44 00000000         ;         (PLLFLLSEL determines MCGFLLCLK' or MCGPLLCLK/2)
   45 00000000         ; 1=   16:PLLFLLSEL=PLL/FLL clock select (MCGPLLCLK/2)
   47 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGPLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
   49 00000000 04010000 
                       SIM_SOPT2_UART0_MCGPLLCLK_DIV2
                               EQU              (SIM_SOPT2_UART0SRC_MCGPLLCLK :OR: SIM_SOPT2_PLLFLLSEL_MASK)
   50 00000000         ;---------------------------------------------------------------
   51 00000000         ;SIM_SOPT5
   52 00000000         ; 0->   16:UART0 open drain enable (disabled)
   53 00000000         ; 0->   02:UART0 receive data select (UART0_RX)
   54 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
   58 00000000 00010007 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:                                  SIM_SOPT
5_UART0RXSRC_MASK :OR:                                  SIM_SOPT5_UART0TXSRC_MASK)
   59 00000000         ;---------------------------------------------------------------
   60 00000000         ;UART0_BDH
   61 00000000         ;    0->  7:LIN break detect IE (disabled)
   62 00000000         ;    0->  6:RxD input active edge IE (disabled)
   63 00000000         ;    0->  5:Stop bit number select (1)
   64 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
   65 00000000         ;UART0CLK is MCGPLLCLK/2
   66 00000000         ;MCGPLLCLK is 96 MHz
   67 00000000         ;MCGPLLCLK/2 is 48 MHz
   68 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   69 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
   70 00000000         ;---------------------------------------------------------------
   71 00000000         ;UART0_BDL
   72 00000000         ;26->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
   73 00000000         ;UART0CLK is MCGPLLCLK/2
   74 00000000         ;MCGPLLCLK is 96 MHz
   75 00000000         ;MCGPLLCLK/2 is 48 MHz
   76 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   77 00000000 00000038 
                       UART0_BDL_9600



ARM Macro Assembler    Page 3 


                               EQU              0x38
   78 00000000         ;---------------------------------------------------------------
   79 00000000         ;UART0_C1
   80 00000000         ;0-->7:LOOPS=loops select (normal)
   81 00000000         ;0-->6:DOZEEN=doze enable (disabled)
   82 00000000         ;0-->5:RSRC=receiver source select (internal--no effect LOOPS=0)
   83 00000000         ;0-->4:M=9- or 8-bit mode select 
   84 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
   85 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
   86 00000000         ;0-->2:IDLE=idle line type select (idle begins after start bit)
   87 00000000         ;0-->1:PE=parity enable (disabled)
   88 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)
   89 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
   90 00000000         ;---------------------------------------------------------------
   91 00000000         ;UART0_C2
   92 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
   93 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
   94 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
   95 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
   96 00000000         ;1-->3:TE=transmitter enable (enabled)
   97 00000000         ;1-->2:RE=receiver enable (enabled)
   98 00000000         ;0-->1:RWU=receiver wakeup control (normal)
   99 00000000         ;0-->0:SBK=send break (disabled, normal)
  100 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2_RE_MASK)
  101 00000000         ;---------------------------------------------------------------
  102 00000000         ;UART0_C3
  103 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  104 00000000         ;           10th data bit for transmitter (not used M10=0)
  105 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  106 00000000         ;           10th data bit for receiver (not used M10=0)
  107 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  108 00000000         ;            (no effect LOOPS=0)
  109 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  110 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  111 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  112 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  113 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  114 00000000 00000000 



ARM Macro Assembler    Page 4 


                       UART0_C3_NO_TXINV
                               EQU              0x00
  115 00000000         ;---------------------------------------------------------------
  116 00000000         ;UART0_C4
  117 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled)
  118 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled)
  119 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  120 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  121 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  122 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  123 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  124 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  125 00000000         ;---------------------------------------------------------------
  126 00000000         ;UART0_C5
  127 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  128 00000000         ;  0-->  6:Reserved; read-only; always 0
  129 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)
  130 00000000         ;000-->4-2:Reserved; read-only; always 0
  131 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only)
  132 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
  133 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  134 00000000         ;---------------------------------------------------------------
  135 00000000         ;UART0_S1
  136 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
  137 00000000         ;0-->6:TC=transmission complete flag; read-only
  138 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  139 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  140 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear)
  141 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  142 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  143 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  144 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              0x1F
  145 00000000         ;---------------------------------------------------------------
  146 00000000         ;UART0_S2



ARM Macro Assembler    Page 5 


  147 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  148 00000000         ;             write 1 to clear
  149 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear)
  150 00000000         ;              write 1 to clear
  151 00000000         ;0-->5:(reserved); read-only; always 0
  152 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  153 00000000         ;0-->3:RWUID=receive wake-up idle detect
  154 00000000         ;0-->2:BRK13=break character generation length (10)
  155 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  156 00000000         ;0-->0:RAF=receiver active flag; read-only
  157 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              0xC0
  158 00000000         ;--------------------------------------------------------------
  159 00000000 0000000D 
                       CR      EQU              0x0D
  160 00000000 0000000A 
                       LF      EQU              0x0A
  161 00000000 0000004F 
                       MAX_STRING
                               EQU              79
  162 00000000         
  163 00000000 00000000 
                       IN_PTR  EQU              0
  164 00000000 00000004 
                       OUT_PTR EQU              4
  165 00000000 00000008 
                       BUF_STRT
                               EQU              8
  166 00000000 0000000C 
                       BUF_PAST
                               EQU              12
  167 00000000 00000010 
                       BUF_SIZE
                               EQU              16
  168 00000000 00000011 
                       NUM_ENQD
                               EQU              17
  169 00000000         
  170 00000000         
  171 00000000 00000004 
                       Q_BUF_SZ



ARM Macro Assembler    Page 6 


                               EQU              4
  172 00000000 00000012 
                       Q_REC_SZ
                               EQU              18
  173 00000000         
  174 00000000         
  175 00000000         ;****************************************************************
  176 00000000         ;Program
  177 00000000         ;Linker requires Reset_Handler
  178 00000000                 AREA             MyCode,CODE,READONLY
  179 00000000                 ENTRY
  180 00000000                 EXPORT           Reset_Handler
  181 00000000                 IMPORT           Startup
  182 00000000         Reset_Handler
  183 00000000         main
  184 00000000         ;---------------------------------------------------------------
  185 00000000         ;Mask interrupts
  186 00000000 B672            CPSID            I
  187 00000002         ;KL46 system startup with 48-MHz system clock
  188 00000002 F7FF FFFE       BL               Startup
  189 00000006         ;---------------------------------------------------------------
  190 00000006         ;---------------------- HEADER -------------------------
  191 00000006         ;Program creates a Queue and has EnQueue and Dequeue functonality
  192 00000006         ;as well as being able to display help and status tables
  193 00000006         ;
  194 00000006         ;these subroutines include but are not limited to
  195 00000006         ;----------InitQueue
  196 00000006         ;----------Enqueue
  197 00000006         ;----------Dequeue
  198 00000006         ;----------PutNumHex
  199 00000006         ;----------GetStringSB
  200 00000006         ;----------PutStringSB
  201 00000006         ;----------PutNumU
  202 00000006         ;----------PutChar
  203 00000006         ;----------GetChar
  204 00000006         ;
  205 00000006         ;the program also used a number of other subroutines that allowed it
  206 00000006         ;to read in the input of the useer
  207 00000006         
  208 00000006         
  209 00000006         ;>>>>> begin main program code <<<<<
  210 00000006         



ARM Macro Assembler    Page 7 


  211 00000006 F000 F931       BL               Init        ;initializing UART0
  212 0000000A 49F0            LDR              R1,=QRecord
  213 0000000C 48F0            LDR              R0,=QBuffer
  214 0000000E 2204            MOVS             R2,#Q_BUF_SZ
  215 00000010 F000 F8C0       BL               InitQueue
  216 00000014         Loop                                 ;infinite loop 
  217 00000014         
  218 00000014 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  219 00000016 48EF            LDR              R0,=InitString ;loading the initial output of "Type a string command (g,
                                                            i,l,p):"
  220 00000018 F000 F9AB       BL               PutStringSB
  221 0000001C         LoopInit
  222 0000001C F000 F965       BL               GetChar     ;getting the first user input
  223 00000020 285A            CMP              R0, #'Z'    ;checking to see if upper case
  224 00000022 4607            MOV              R7,R0       ;saving the original value for later
  225 00000024 D90A            BLS              UpperCase   ;if it is uppercase, branch and fix it
  226 00000026         
  227 00000026         Back                                 ;back from uppercase fix
  228 00000026 2864            CMP              R0, #'d'    ;checking if 'd'
  229 00000028 D017            BEQ              CorrectD
  230 0000002A 2865            CMP              R0, #'e'    ;checking if 'e'
  231 0000002C D029            BEQ              CorrectE
  232 0000002E 2868            CMP              R0, #'h'    ;checking if 'h'
  233 00000030 D042            BEQ              CorrectH
  234 00000032 2870            CMP              R0, #'p'    ;checking if 'p'
  235 00000034 D04D            BEQ              CorrectP
  236 00000036 2873            CMP              R0, #'s'    ;checking if 's'
  237 00000038 D078            BEQ              CorrectS
  238 0000003A         
  239 0000003A         
  240 0000003A E7EF            B                LoopInit    ;looping forever
  241 0000003C         
  242 0000003C         
  243 0000003C         
  244 0000003C         ;----------------------- UpperCase ----------------------------
  245 0000003C         ;Recieves R0
  246 0000003C         ;Outputs Converted into R0, original in R7
  247 0000003C         ;Subroutine used to convert uppercase input into lowercase equivilant
  248 0000003C         UpperCase
  249 0000003C 0007            MOVS             R7,R0       ;saves initial value in R7
  250 0000003E 3020            ADDS             R0,R0,#32   ;converts to lower case
  251 00000040 F7FF FFF1       BL               Back



ARM Macro Assembler    Page 8 


  252 00000044         
  253 00000044         Correct
  254 00000044 B501            PUSH             {R0, LR}
  255 00000046 0038            MOVS             R0,R7       ;printing original value
  256 00000048 F000 F946       BL               PutChar
  257 0000004C         
  258 0000004C 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  259 0000004E F000 F943       BL               PutChar
  260 00000052 200A            MOVS             R0,#LF
  261 00000054 F000 F940       BL               PutChar
  262 00000058 BD01            POP              {R0, PC}
  263 0000005A         
  264 0000005A         
  265 0000005A         
  266 0000005A         
  267 0000005A         ;----------------------- D ----------------------------
  268 0000005A         ;Calls if D is pushed, calls Dequeue
  269 0000005A         CorrectD
  270 0000005A B478            PUSH             {R3,R4,R5,R6}
  271 0000005C F7FF FFF2       BL               Correct     ;Base correct subroutine that sets up subroutines
  272 00000060         
  273 00000060 49DA            LDR              R1,=QRecord ;loading queue record in to R1
  274 00000062 F000 F8A1       BL               DeQueue     ;dequeuing
  275 00000066         
  276 00000066         
  277 00000066 D207            BCS              ZERO_1      ;is called if carry flag is set, meaning a failure
  278 00000068 F000 F936       BL               PutChar     ;placing character
  279 0000006C 48DA            LDR              R0,=DQGDS
  280 0000006E 214F            MOVS             R1,#MAX_STRING
  281 00000070 F000 F97F       BL               PutStringSB
  282 00000074         
  283 00000074         
  284 00000074 BC78            POP              {R3,R4,R5,R6}
  285 00000076         
  286 00000076 E067            B                CorrectS_1  ;jumps to status subroutine
  287 00000078         
  288 00000078         
  289 00000078         
  290 00000078         ;--------------------------- Zero Case -----------------------------
  291 00000078         ;used to print out the failure case
  292 00000078         ZERO_1
  293 00000078 48D8            LDR              R0,=Failure ;failure string



ARM Macro Assembler    Page 9 


  294 0000007A 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  295 0000007C F000 F979       BL               PutStringSB
  296 00000080         
  297 00000080 E062            B                CorrectS_1  ;jumps to status subroutine
  298 00000082         
  299 00000082         ;----------------------- E ----------------------------
  300 00000082         ;Recives character to enqueu in R0
  301 00000082         ;Calls if the user inputed E, does enqueu command and takes in a character
  302 00000082         CorrectE
  303 00000082 F7FF FFDF       BL               Correct     ;Base correct subroutine that sets up subroutines
  304 00000086 49D7            LDR              R1,=MAX_STRING
  305 00000088 48D5            LDR              R0,=CTE     ;loading string
  306 0000008A F000 F972       BL               PutStringSB
  307 0000008E F000 F92C       BL               GetChar
  308 00000092 0002            MOVS             R2,R0
  309 00000094         
  310 00000094 F000 F920       BL               PutChar
  311 00000098 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  312 0000009A F000 F91D       BL               PutChar
  313 0000009E 200A            MOVS             R0,#LF
  314 000000A0 F000 F91A       BL               PutChar
  315 000000A4         
  316 000000A4 0010            MOVS             R0,R2
  317 000000A6 49C9            LDR              R1,=QRecord ;initializing QRecord
  318 000000A8 F000 F8A1       BL               Enqueue     ;enqueuing
  319 000000AC         
  320 000000AC         
  321 000000AC D36C            BCC              CarryClear_01
  322 000000AE 48CB            LDR              R0,=Failure ;failure print
  323 000000B0 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  324 000000B2 F000 F95E       BL               PutStringSB
  325 000000B6         
  326 000000B6         
  327 000000B6         
  328 000000B6 E047            B                CorrectS_1  ;jumps to status subroutine
  329 000000B8         
  330 000000B8         
  331 000000B8         ;----------------------- H ---------------------------
  332 000000B8         ;Called if the user inputed H, this is the help command
  333 000000B8         CorrectH
  334 000000B8 F7FF FFC4       BL               Correct     ;Base correct subroutine that sets up subroutines
  335 000000BC 48CA            LDR              R0,=Help



ARM Macro Assembler    Page 10 


  336 000000BE 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  337 000000C0 F000 F957       BL               PutStringSB
  338 000000C4         
  339 000000C4 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  340 000000C6 F000 F907       BL               PutChar
  341 000000CA 200A            MOVS             R0,#LF
  342 000000CC F000 F904       BL               PutChar
  343 000000D0         
  344 000000D0 E7A0            B                Loop        ;no status, so loops back
  345 000000D2         
  346 000000D2         ;----------------------- P ----------------------------
  347 000000D2         ;Called if th euser inputed P, this is the print command
  348 000000D2         CorrectP
  349 000000D2 F7FF FFB7       BL               Correct     ;Base correct subroutine that sets up subroutines
  350 000000D6 203E            MOVS             R0,#'>'     ;printing '>'
  351 000000D8 F000 F8FE       BL               PutChar
  352 000000DC         
  353 000000DC 49BB            LDR              R1,=QRecord ;loading QRecord
  354 000000DE 680A            LDR              R2,[R1,#IN_PTR]
  355 000000E0 7C4C            LDRB             R4,[R1,#NUM_ENQD]
  356 000000E2 684D            LDR              R5,[R1,#OUT_PTR]
  357 000000E4 688E            LDR              R6,[R1,#BUF_STRT]
  358 000000E6 68CB            LDR              R3,[R1,#BUF_PAST]
  359 000000E8         
  360 000000E8         
  361 000000E8 2700            MOVS             R7,#0
  362 000000EA 42AA            CMP              R2,R5
  363 000000EC D01B            BEQ              EQUAL_P     ;branches if there is an exceptinon wher in_ptr and
  364 000000EE         ;out_ptr equal but there are items in the queue, so
  365 000000EE         ;need to traverse it
  366 000000EE         Loop_P
  367 000000EE 4295            CMP              R5,R2       ;checks if out_ptr = in_ptr
  368 000000F0 D009            BEQ              DONE_P
  369 000000F2 42BC            CMP              R4,R7       ;checks if counter equals num_enqud
  370 000000F4 D007            BEQ              DONE_P
  371 000000F6         
  372 000000F6         Excepetion                           ;skips previouse in case there was and exception
  373 000000F6 429D            CMP              R5,R3
  374 000000F8 D00F            BEQ              OVER_P
  375 000000FA         
  376 000000FA 7828            LDRB             R0,[R5,#0]  ;placing the character that is currently enqueued by the poi
                                                            nter



ARM Macro Assembler    Page 11 


  377 000000FC F000 F8EC       BL               PutChar
  378 00000100         
  379 00000100         
  380 00000100         
  381 00000100 1C6D            ADDS             R5,R5,#1    ;increments
  382 00000102 1C7F            ADDS             R7,R7,#1
  383 00000104         
  384 00000104 E7F3            B                Loop_P
  385 00000106         
  386 00000106         
  387 00000106         DONE_P                               ;done with printing
  388 00000106         
  389 00000106 203C            MOVS             R0,#'<'     ;printing '>'
  390 00000108 F000 F8E6       BL               PutChar
  391 0000010C         
  392 0000010C 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  393 0000010E F000 F8E3       BL               PutChar
  394 00000112 200A            MOVS             R0,#LF
  395 00000114 F000 F8E0       BL               PutChar
  396 00000118 E016            B                CorrectS_1  ;jumps to status subroutine
  397 0000011A         
  398 0000011A         
  399 0000011A         
  400 0000011A         OVER_P
  401 0000011A 0035            MOVS             R5,R6       ;if the inpointer reaches the buffer limit but does not equa
                                                            l in_ptr,
  402 0000011C 7828            LDRB             R0,[R5,#0]  ;jump back to the begginign
  403 0000011E F000 F8DB       BL               PutChar
  404 00000122 1C7F            ADDS             R7,R7,#1
  405 00000124 E7E3            B                Loop_P
  406 00000126         EQUAL_P
  407 00000126 42BC            CMP              R4,R7
  408 00000128 D1E5            BNE              Excepetion
  409 0000012A E7EC            B                DONE_P
  410 0000012C         
  411 0000012C         ;----------------------- S ----------------------------
  412 0000012C         ;if the user implement S then the Status is printed
  413 0000012C         ;Takes in a the user input and then procedes to print the queue
  414 0000012C         ;in the order that they would be removed
  415 0000012C         CorrectS
  416 0000012C 0038            MOVS             R0,R7       ;printing original value
  417 0000012E F000 F8D3       BL               PutChar



ARM Macro Assembler    Page 12 


  418 00000132 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  419 00000134 F000 F8D0       BL               PutChar
  420 00000138 200A            MOVS             R0,#LF
  421 0000013A F000 F8CD       BL               PutChar
  422 0000013E 48AB            LDR              R0,=Status  ;printing Status
  423 00000140 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  424 00000142 F000 F916       BL               PutStringSB
  425 00000146 E7FF            B                CorrectS_1
  426 00000148         
  427 00000148         
  428 00000148         CorrectS_1                           ;Basic status print used by all subroutines
  429 00000148 48A9            LDR              R0,=Ln
  430 0000014A 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  431 0000014C F000 F911       BL               PutStringSB
  432 00000150         
  433 00000150 499E            LDR              R1,=QRecord
  434 00000152 6808            LDR              R0,[R1,#IN_PTR]
  435 00000154 F000 F86E       BL               PutNumHex
  436 00000158         
  437 00000158 48A6            LDR              R0,=OUT
  438 0000015A 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  439 0000015C F000 F909       BL               PutStringSB
  440 00000160         
  441 00000160 499A            LDR              R1,=QRecord
  442 00000162 6848            LDR              R0,[R1,#OUT_PTR]
  443 00000164 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  444 00000166 F000 F865       BL               PutNumHex
  445 0000016A         
  446 0000016A 48A3            LDR              R0,=Num
  447 0000016C 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  448 0000016E F000 F900       BL               PutStringSB
  449 00000172         
  450 00000172 4996            LDR              R1,=QRecord
  451 00000174 7C48            LDRB             R0,[R1,#NUM_ENQD]
  452 00000176 F000 F8E8       BL               PutNumU
  453 0000017A         
  454 0000017A 200D            MOVS             R0,#CR      ;Moves to the new line, all the way to the left
  455 0000017C F000 F8AC       BL               PutChar
  456 00000180 200A            MOVS             R0,#LF
  457 00000182 F000 F8A9       BL               PutChar
  458 00000186         
  459 00000186 E745            B                Loop



ARM Macro Assembler    Page 13 


  460 00000188         
  461 00000188         
  462 00000188         
  463 00000188         
  464 00000188         
  465 00000188         
  466 00000188         ;------------------------ CarryClear_01----------------------------
  467 00000188         ;used by multiple subrotines to print out success
  468 00000188         CarryClear_01
  469 00000188 489C            LDR              R0,=Success
  470 0000018A 214F            MOVS             R1,#MAX_STRING ;loading buffer capacity
  471 0000018C F000 F8F1       BL               PutStringSB
  472 00000190         
  473 00000190 E7DA            B                CorrectS_1  ;jumps to status subroutine
  474 00000192         
  475 00000192         
  476 00000192         
  477 00000192         
  478 00000192         
  479 00000192         ;>>>>>   end main program code <<<<<
  480 00000192         ;Stay here
  481 00000192 E7FE            B                .
  482 00000194         
  483 00000194         ;>>>>> begin subroutine code <<<<<
  484 00000194         ;---------------------- InitQueue ------------------
  485 00000194         ;initilizes the queue, R1 must be queue record
  486 00000194         InitQueue
  487 00000194         
  488 00000194 B501            PUSH             {R0,LR}
  489 00000196         
  490 00000196 6008            STR              R0,[R1,#IN_PTR]
  491 00000198 6048            STR              R0,[R1,#OUT_PTR]
  492 0000019A 6088            STR              R0,[R1,#BUF_STRT]
  493 0000019C 1880            ADDS             R0,R0,R2
  494 0000019E 60C8            STR              R0,[R1,#BUF_PAST]
  495 000001A0 740A            STRB             R2,[R1,#BUF_SIZE]
  496 000001A2 2000            MOVS             R0,#0
  497 000001A4 7448            STRB             R0,[R1,#NUM_ENQD]
  498 000001A6         
  499 000001A6         
  500 000001A6         
  501 000001A6 BD01            POP              {R0,PC}



ARM Macro Assembler    Page 14 


  502 000001A8         
  503 000001A8         
  504 000001A8         
  505 000001A8         
  506 000001A8         ;---------------------- DeQueue ------------------
  507 000001A8         ;R1 Address of Queue record structure
  508 000001A8         ;C flag succes(0)
  509 000001A8         ;the deuque subrotine, dequeus and advances the pointer
  510 000001A8         DeQueue
  511 000001A8         
  512 000001A8 B5FE            PUSH             {R1-R7,LR}
  513 000001AA         
  514 000001AA 7C4C            LDRB             R4,[R1,#NUM_ENQD] ;loading values
  515 000001AC 680D            LDR              R5,[R1,#IN_PTR]
  516 000001AE 688E            LDR              R6,[R1,#BUF_STRT]
  517 000001B0 684F            LDR              R7,[R1,#OUT_PTR]
  518 000001B2 68CB            LDR              R3,[R1,#BUF_PAST]
  519 000001B4         
  520 000001B4         
  521 000001B4 2C00            CMP              R4,#0       ;checks if size is zero
  522 000001B6 D00F            BEQ              Failed_Dequeue
  523 000001B8 783A            LDRB             R2,[R7,#0]
  524 000001BA         
  525 000001BA 1C7F            ADDS             R7,R7,#1
  526 000001BC 1E64            SUBS             R4,R4,#1
  527 000001BE         
  528 000001BE         
  529 000001BE 744C            STRB             R4,[R1,#NUM_ENQD] ;storing back into loacation
  530 000001C0 604F            STR              R7,[R1,#OUT_PTR]
  531 000001C2         
  532 000001C2 429F            CMP              R7,R3
  533 000001C4 D010            BEQ              InPointer_Bigger2 ;if pointer procgressing past buffer limit,
  534 000001C6         ;then advacne back
  535 000001C6         
  536 000001C6 F3EF 8000       MRS              R0,APSR     ; sets C flag to clear
  537 000001CA 2020            MOVS             R0,#0x20
  538 000001CC 0609            LSLS             R1,R1,#24
  539 000001CE 4388            BICS             R0,R0,R1
  540 000001D0 F380 8800       MSR              APSR,R0
  541 000001D4 0010            MOVS             R0,R2
  542 000001D6         
  543 000001D6         



ARM Macro Assembler    Page 15 


  544 000001D6         
  545 000001D6         
  546 000001D6         DoneD1
  547 000001D6 BDFE            POP              {R1-R7,PC}
  548 000001D8         
  549 000001D8         Failed_Dequeue
  550 000001D8         ;Unsuccesfull
  551 000001D8 F3EF 8000       MRS              R0,APSR     ;manually sets C flag to set
  552 000001DC 2120            MOVS             R1,#0x20
  553 000001DE 0609            LSLS             R1,R1,#24
  554 000001E0 4308            ORRS             R0,R0,R1
  555 000001E2 F380 8800       MSR              APSR,R0
  556 000001E6 E7F6            B                DoneD1
  557 000001E8         
  558 000001E8         InPointer_Bigger2
  559 000001E8 0037            MOVS             R7,R6       ;manually moving the pointer back to start
  560 000001EA 604F            STR              R7,[R1,#OUT_PTR]
  561 000001EC E7F3            B                DoneD1
  562 000001EE         
  563 000001EE         
  564 000001EE         
  565 000001EE         
  566 000001EE         
  567 000001EE         
  568 000001EE         ;---------------------- EnQueue ------------------
  569 000001EE         ;R0 Character to enqueue
  570 000001EE         ;R1 Address of Queue record structure
  571 000001EE         ;C flag succes(0)
  572 000001EE         ;Enqueues the recived value and advances
  573 000001EE         Enqueue
  574 000001EE         
  575 000001EE B57D            PUSH             {R0,R2-R6,LR}
  576 000001F0         
  577 000001F0 7C0B            LDRB             R3,[R1,#BUF_SIZE] ;initializing the queue structure
  578 000001F2 7C4C            LDRB             R4,[R1,#NUM_ENQD]
  579 000001F4 680D            LDR              R5,[R1,#IN_PTR]
  580 000001F6 688E            LDR              R6,[R1,#BUF_STRT]
  581 000001F8 68CF            LDR              R7,[R1,#BUF_PAST]
  582 000001FA         
  583 000001FA         
  584 000001FA 429C            CMP              R4,R3
  585 000001FC D012            BEQ              Failed_Enqueue ;fails if the queue is full



ARM Macro Assembler    Page 16 


  586 000001FE 7028            STRB             R0,[R5,#0]  ;stores value
  587 00000200 1C6D            ADDS             R5,R5,#1    ;advances counters
  588 00000202 1C64            ADDS             R4,R4,#1
  589 00000204         
  590 00000204 600D            STR              R5,[R1,#IN_PTR] ;stores back
  591 00000206 744C            STRB             R4,[R1,#NUM_ENQD]
  592 00000208         
  593 00000208 42BD            CMP              R5,R7
  594 0000020A D008            BEQ              InPointer_Bigger1 ;if inpointer reaches end of the queue, go back
  595 0000020C         
  596 0000020C         
  597 0000020C         
  598 0000020C         Done
  599 0000020C F3EF 8000       MRS              R0,APSR     ; sets C flag to clear
  600 00000210 2020            MOVS             R0,#0x20
  601 00000212 0609            LSLS             R1,R1,#24
  602 00000214 4388            BICS             R0,R0,R1
  603 00000216 F380 8800       MSR              APSR,R0
  604 0000021A 2000            MOVS             R0,#0
  605 0000021C         
  606 0000021C         
  607 0000021C BD7D            POP              {R0,R2-R6,PC}
  608 0000021E         
  609 0000021E         
  610 0000021E         InPointer_Bigger1                    ;if the inpointer is bigger, manually set it back
  611 0000021E 0035            MOVS             R5,R6
  612 00000220 600D            STR              R5,[R1,#IN_PTR]
  613 00000222 E7F3            B                Done
  614 00000224         
  615 00000224         Failed_Enqueue
  616 00000224 F3EF 8000       MRS              R0,APSR     ; manually sets C flag to set
  617 00000228 2120            MOVS             R1,#0x20
  618 0000022A 0609            LSLS             R1,R1,#24
  619 0000022C 4308            ORRS             R0,R0,R1
  620 0000022E F380 8800       MSR              APSR,R0
  621 00000232 BD7D            POP              {R0,R2-R6,PC}
  622 00000234         
  623 00000234         
  624 00000234         ;--------------------------- PutNumHEx---------------
  625 00000234         ;converts address into hex value
  626 00000234         PutNumHex
  627 00000234 B53F            PUSH             {R0-R5,LR}



ARM Macro Assembler    Page 17 


  628 00000236         
  629 00000236 221C            MOVS             R2,#28      ;defining constants that will need to be added
  630 00000238 230F            MOVS             R3,#0x0000000F
  631 0000023A 0004            MOVS             R4,R0
  632 0000023C 2508            MOVS             R5,#8
  633 0000023E         
  634 0000023E         Loop_PNH
  635 0000023E         
  636 0000023E 40D0            LSRS             R0,R0,R2    ;shifiting by how much we need
  637 00000240 4018            ANDS             R0,R3
  638 00000242 2809            CMP              R0,#9
  639 00000244 D908            BLS              Number_PNH  ;checks if number
  640 00000246 3037            ADDS             R0,R0,#55   ;if not assume its letter
  641 00000248 F000 F846       BL               PutChar
  642 0000024C 0020            MOVS             R0,R4
  643 0000024E         
  644 0000024E 1F12            SUBS             R2,R2,#4    ;incrementing 
  645 00000250 1E6D            SUBS             R5,R5,#1
  646 00000252 2D00            CMP              R5,#0
  647 00000254 D009            BEQ              Done_PNH
  648 00000256 E7F2            B                Loop_PNH
  649 00000258         
  650 00000258         
  651 00000258         
  652 00000258         
  653 00000258         Number_PNH
  654 00000258 3030            ADDS             R0,R0,#0x00000030 ;speical case for number 
  655 0000025A F000 F83D       BL               PutChar
  656 0000025E 0020            MOVS             R0,R4
  657 00000260         
  658 00000260 1F12            SUBS             R2,R2,#4
  659 00000262 1E6D            SUBS             R5,R5,#1
  660 00000264 2D00            CMP              R5,#0
  661 00000266 D000            BEQ              Done_PNH
  662 00000268 E7E9            B                Loop_PNH
  663 0000026A         
  664 0000026A         Done_PNH
  665 0000026A BD3F            POP              {R0-R5,PC}
  666 0000026C         
  667 0000026C         
  668 0000026C         
  669 0000026C         ;--------------------------- INIT -----------------------



ARM Macro Assembler    Page 18 


  670 0000026C         Init                                 ;copy and paste code initializing UART0
  671 0000026C B40E            PUSH             { R1, R2, R3}
  672 0000026E         ;Select MCGPLLCLK / 2 as UART0 clock source
  673 0000026E 486B            LDR              R0,=SIM_SOPT2
  674 00000270 496B            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  675 00000272 6802            LDR              R2,[R0,#0]
  676 00000274 438A            BICS             R2,R2,R1
  677 00000276 496B            LDR              R1,=SIM_SOPT2_UART0_MCGPLLCLK_DIV2
  678 00000278 430A            ORRS             R2,R2,R1
  679 0000027A 6002            STR              R2,[R0,#0]
  680 0000027C         ;Enable external connection for UART0
  681 0000027C 486A            LDR              R0,=SIM_SOPT5
  682 0000027E 496B            LDR              R1,= SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
  683 00000280 6802            LDR              R2,[R0,#0]
  684 00000282 438A            BICS             R2,R2,R1
  685 00000284 6002            STR              R2,[R0,#0]
  686 00000286         ;Enable clock for UART0 module
  687 00000286 486A            LDR              R0,=SIM_SCGC4
  688 00000288 496A            LDR              R1,= SIM_SCGC4_UART0_MASK
  689 0000028A 6802            LDR              R2,[R0,#0]
  690 0000028C 430A            ORRS             R2,R2,R1
  691 0000028E 6002            STR              R2,[R0,#0]
  692 00000290         ;Enable clock for Port A module
  693 00000290 4869            LDR              R0,=SIM_SCGC5
  694 00000292 496A            LDR              R1,= SIM_SCGC5_PORTA_MASK
  695 00000294 6802            LDR              R2,[R0,#0]
  696 00000296 430A            ORRS             R2,R2,R1
  697 00000298 6002            STR              R2,[R0,#0]
  698 0000029A         ;Connect PORT A Pin 1 (PTA1) to UART0 Rx (J1 Pin 02)
  699 0000029A 4869            LDR              R0,=PORTA_PCR1
  700 0000029C 4969            LDR              R1,=PORT_PCR_SET_PTA1_UART0_RX
  701 0000029E 6001            STR              R1,[R0,#0]
  702 000002A0         ;Connect PORT A Pin 2 (PTA2) to UART0 Tx (J1 Pin 04)
  703 000002A0 4869            LDR              R0,=PORTA_PCR2
  704 000002A2 4968            LDR              R1,=PORT_PCR_SET_PTA2_UART0_TX
  705 000002A4 6001            STR              R1,[R0,#0]
  706 000002A6         
  707 000002A6         
  708 000002A6         
  709 000002A6         
  710 000002A6         ;Disable UART0 receiver and transmitter
  711 000002A6 4869            LDR              R0,=UART0_BASE



ARM Macro Assembler    Page 19 


  712 000002A8 210C            MOVS             R1,#UART0_C2_T_R
  713 000002AA 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  714 000002AC 438A            BICS             R2,R2,R1
  715 000002AE 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  716 000002B0         ;Set UART0 for 9600 baud, 8N1 protocol
  717 000002B0 2101            MOVS             R1,#UART0_BDH_9600
  718 000002B2 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  719 000002B4 2138            MOVS             R1,#UART0_BDL_9600
  720 000002B6 7041            STRB             R1,[R0,#UART0_BDL_OFFSET] ;Somethign on here
  721 000002B8 2100            MOVS             R1,#UART0_C1_8N1
  722 000002BA 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  723 000002BC 2100            MOVS             R1,#UART0_C3_NO_TXINV
  724 000002BE 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  725 000002C0 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  726 000002C2 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  727 000002C4 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  728 000002C6 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  729 000002C8 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  730 000002CA 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  732 000002CC 21C0            MOVS             R1,    #UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
  733 000002CE 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  734 000002D0         ;Enable UART0 receiver and transmitter
  735 000002D0 210C            MOVS             R1,#UART0_C2_T_R
  736 000002D2 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  737 000002D4         
  738 000002D4 BC0E            POP              { R1, R2, R3}
  739 000002D6         
  740 000002D6 4770            BX               LR
  741 000002D8         
  742 000002D8         ;--------------------------- PUTCHAR -----------------------
  743 000002D8         PutChar                              ;copy and paste code of Putchar
  744 000002D8 B40E            PUSH             { R1, R2, R3 }
  745 000002DA         ;Poll TDRE until UART0 ready to transmit
  746 000002DA 495C            LDR              R1,=UART0_BASE
  747 000002DC 2280            MOVS             R2,#UART0_S1_TDRE_MASK
  748 000002DE 790B    PollTx  LDRB             R3,[R1,#UART0_S1_OFFSET]
  749 000002E0 4013            ANDS             R3,R3,R2
  750 000002E2 D0FC            BEQ              PollTx
  751 000002E4         ;Transmit character stored in Ri
  752 000002E4 71C8            STRB             R0,[R1,#UART0_D_OFFSET]
  753 000002E6         
  754 000002E6 BC0E            POP              { R1, R2, R3 }



ARM Macro Assembler    Page 20 


  755 000002E8         
  756 000002E8 4770            BX               LR
  757 000002EA         
  758 000002EA         ;--------------------------- GETCHAR -----------------------
  759 000002EA         GetChar                              ;copy and paste code of Getchar
  760 000002EA B40E            PUSH             { R1, R2, R3 }
  761 000002EC         ;Poll RDRF until UART0 ready to receive
  762 000002EC 4957            LDR              R1,=UART0_BASE
  763 000002EE 2220            MOVS             R2,#UART0_S1_RDRF_MASK
  764 000002F0 790B    PollRx  LDRB             R3,[R1,#UART0_S1_OFFSET]
  765 000002F2 4013            ANDS             R3,R3,R2
  766 000002F4 D0FC            BEQ              PollRx
  767 000002F6         ;Receive character and store in Ri
  768 000002F6 79C8            LDRB             R0,[R1,#UART0_D_OFFSET]
  769 000002F8 BC0E            POP              { R1, R2, R3 }
  770 000002FA         
  771 000002FA 4770            BX               LR
  772 000002FC         
  773 000002FC         
  774 000002FC         
  775 000002FC         ;--------------------------- GETSTRINGSB -----------------------  
  776 000002FC         GetStringSB
  777 000002FC B51F            PUSH             { R0 - R4, LR }
  778 000002FE 2300            MOVS             R3,#0       ;initializing counter
  779 00000300 0004            MOVS             R4,R0       ;storing adress
  780 00000302 1E49            SUBS             R1,R1,#1    ;subtracting buffer capacity
  781 00000304         
  782 00000304         Loop1A                               ;super loop
  783 00000304 F7FF FFF1       BL               GetChar     ;checking if input is "enter"
  784 00000308 280D            CMP              R0, #CR
  785 0000030A D00B            BEQ              Enter       ;branching if it is
  786 0000030C         
  787 0000030C         
  788 0000030C 4299            CMP              R1,R3       ;checking if index = buffer cpacity
  789 0000030E D004            BEQ              Skip        ;if it is, skip
  790 00000310 54E0            STRB             R0,[R4,R3]  ;otherwise store in adress with value (R0) at address (R4) o
                                                            ffset of increment (R3)
  791 00000312 1C5B            ADDS             R3,R3,#1    ;incrementing counter
  792 00000314         
  793 00000314         
  794 00000314 F7FF FFE0       BL               PutChar     ;printing it
  795 00000318 E7F4            B                Loop1A      ;looping almost forever



ARM Macro Assembler    Page 21 


  796 0000031A         
  797 0000031A         Skip
  798 0000031A F7FF FFE6       BL               GetChar     ;triggered if buffercapacity over limit and ignores everythi
                                                            ng until enter is hit
  799 0000031E 280D            CMP              R0, #CR
  800 00000320 D000            BEQ              Enter
  801 00000322 E7FA            B                Skip
  802 00000324         Enter                                ;if enter was hit
  803 00000324 2000            MOVS             R0,#0       ;storing '0' at end
  804 00000326 54E0            STRB             R0,[R4,R3]
  805 00000328 200D            MOVS             R0,#CR      ;printing new line
  806 0000032A F7FF FFD5       BL               PutChar
  807 0000032E 200A            MOVS             R0,#LF
  808 00000330 F7FF FFD2       BL               PutChar
  809 00000334 BD1F            POP              { R0 - R4, PC }
  810 00000336         
  811 00000336         ;--------------------------- LENGTHSTRINGSB -----------------------  
  812 00000336         LengthStringSB
  813 00000336 B50A            PUSH             { R1, R3, LR }
  814 00000338         
  815 00000338 2200            MOVS             R2,#0       ;initializing counter
  816 0000033A         
  817 0000033A         Loop2
  818 0000033A 5C83            LDRB             R3,[R0,R2]  ;loading value in string
  819 0000033C 2B00            CMP              R3,#0       ;checking if '0', if it is, run away
  820 0000033E D003            BEQ              Ende
  821 00000340 428A            CMP              R2, R1      ;checking if counter = buffercapacity, if it does, run away
  822 00000342 D001            BEQ              Ende
  823 00000344 1C52            ADDS             R2,R2, #1
  824 00000346         
  825 00000346 E7F8            B                Loop2       ;looping almost forver
  826 00000348         Ende
  827 00000348         
  828 00000348 BD0A            POP              { R1, R3, PC }
  829 0000034A         
  830 0000034A         ;--------------------------- PUTNUMU -----------------------
  831 0000034A         ;prints the number in decimal form in R0
  832 0000034A         PutNumU
  833 0000034A B507            PUSH             { R0 - R2, LR }
  834 0000034C 2200            MOVS             R2,#0       ;initializng counter
  835 0000034E         Loop3
  836 0000034E 0001            MOVS             R1, R0      ;setting up for DIVU (R1 divedend, R0 divider)



ARM Macro Assembler    Page 22 


  837 00000350 200A            MOVS             R0, #10
  838 00000352 F000 F81B       BL               DIVU        ;calling DIVU
  839 00000356 B402            PUSH             {R1}        ;storing in stack because it gets values in revers order
  840 00000358 1C52            ADDS             R2,R2,#1
  841 0000035A 2800            CMP              R0, #0      ;checking done
  842 0000035C D000            BEQ              Out         ;if it is, end
  843 0000035E E7F6            B                Loop3
  844 00000360         
  845 00000360         Out
  846 00000360 BC01            POP              {R0}        ;finishing up
  847 00000362 1E52            SUBS             R2,R2,#1
  848 00000364 3030            ADDS             R0,R0,#'0'
  849 00000366 F7FF FFB7       BL               PutChar
  850 0000036A 2A00            CMP              R2,#0
  851 0000036C D000            BEQ              Done4
  852 0000036E E7F7            B                Out
  853 00000370         
  854 00000370         Done4
  855 00000370 BD07            POP              { R0 - R2, PC }
  856 00000372         
  857 00000372         
  858 00000372         ;--------------------------- PUTSTRINGSB -----------------------
  859 00000372         ;puts the string stored in R0
  860 00000372         PutStringSB
  861 00000372 B50F            PUSH             { R0, R1, R2, R3, LR }
  862 00000374         
  863 00000374 2300            MOVS             R3,#0       ;counter
  864 00000376 0002            MOVS             R2,R0       ;R2 gets adress
  865 00000378         
  866 00000378         Loop4
  867 00000378 428B            CMP              R3,R1       ;compares counter with MAX SIZE
  868 0000037A D006            BEQ              Ende2
  869 0000037C         
  870 0000037C 5CD0            LDRB             R0,[R2,R3]  ;loads value at R2 offset R3 into R0
  871 0000037E 2800            CMP              R0,#0       ;checks if null terminator
  872 00000380 D003            BEQ              Ende2
  873 00000382         
  874 00000382 F7FF FFA9       BL               PutChar     ;prints
  875 00000386 1C5B            ADDS             R3,R3, #1   ;adds to counter
  876 00000388         
  877 00000388 E7F6            B                Loop4
  878 0000038A         Ende2



ARM Macro Assembler    Page 23 


  879 0000038A         
  880 0000038A BD0F            POP              { R0, R1, R2, R3, PC }
  881 0000038C         
  882 0000038C         
  883 0000038C         ;--------------------------- DIVU -----------------------
  884 0000038C         ;takes in Diveded (R1) and Divisor (R0)
  885 0000038C         
  886 0000038C         DIVU
  887 0000038C         
  888 0000038C B404            PUSH             {R2}        ;Pushing R2 to save
  889 0000038E 2200            MOVS             R2,#0
  890 00000390 2800            CMP              R0,#0       ;checks if Divide by zero
  891 00000392 D009            BEQ              DIV_BY_ZERO
  892 00000394         
  893 00000394         
  894 00000394         
  895 00000394 2900            CMP              R1,#0       ;checks if Dividend is zero
  896 00000396 D00F            BEQ              EndIFF
  897 00000398         
  898 00000398 4281    While   CMP              R1,R0       ;the main loop where Dividen is conitunually subtracted
  899 0000039A D302            BLO              Endwhile    ;by the Divider until Dividen is either 0 or less than
  900 0000039C         ;the Divider... R2 is used as the quotient
  901 0000039C 1A09            SUBS             R1,R1,R0
  902 0000039E 1C52            ADDS             R2,R2,#1
  903 000003A0         
  904 000003A0 E7FA            B                While
  905 000003A2         Endwhile
  906 000003A2 0010            MOVS             R0,R2
  907 000003A4         
  908 000003A4         
  909 000003A4         
  910 000003A4         
  911 000003A4         
  912 000003A4 BC04    DIVU_DONE
                               POP              {R2}        ;DIVU_DONE used when needed to return out of DIVU subroutine
                                                            
  913 000003A6         
  914 000003A6 4770            BX               LR
  915 000003A8         
  916 000003A8         
  917 000003A8 F3EF 8000 
                       DIV_BY_ZERO



ARM Macro Assembler    Page 24 


                               MRS              R0,APSR     ;Divide by zeros manually sets C flag to set
  918 000003AC 2120            MOVS             R1,#0x20
  919 000003AE 0609            LSLS             R1,R1,#24
  920 000003B0 4308            ORRS             R0,R0,R1
  921 000003B2 F380 8800       MSR              APSR,R0
  922 000003B6 E7F5            B                DIVU_DONE
  923 000003B8         
  924 000003B8         
  925 000003B8 F3EF 8000 
                       EndIFF  MRS              R0,APSR     ;EndIFF manually sets C flag to clear if dividend is 0
  926 000003BC 2020            MOVS             R0,#0x20
  927 000003BE 0609            LSLS             R1,R1,#24
  928 000003C0 4388            BICS             R0,R0,R1
  929 000003C2 F380 8800       MSR              APSR,R0
  930 000003C6 2000            MOVS             R0,#0
  931 000003C8         
  932 000003C8 E7EC            B                DIVU_DONE
  933 000003CA         
  934 000003CA         
  935 000003CA         
  936 000003CA         
  937 000003CA         
  938 000003CA         
  939 000003CA         ;>>>>>   end subroutine code <<<<<
  940 000003CA 00 00           ALIGN
  941 000003CC         ;****************************************************************
  942 000003CC         ;Vector Table Mapped to Address 0 at Reset
  943 000003CC         ;Linker requires __Vectors to be exported
  944 000003CC 00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              0000004F 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 



ARM Macro Assembler    Page 25 


              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              40048004 
              0C000000 
              04010000 
              40048010 
              00010007 
              40048034 
              00000400 
              40048038 
              00000200 
              40049004 
              01000200 
              40049008 
              4006A000         AREA             RESET, DATA, READONLY
  945 00000000                 EXPORT           __Vectors
  946 00000000                 EXPORT           __Vectors_End
  947 00000000                 EXPORT           __Vectors_Size
  948 00000000                 IMPORT           __initial_sp
  949 00000000                 IMPORT           Dummy_Handler
  950 00000000         __Vectors
  951 00000000         ;ARM core vectors
  952 00000000 00000000        DCD              __initial_sp ;00:end of stack
  953 00000004 00000000        DCD              Reset_Handler ;01:reset vector
  954 00000008 00000000        DCD              Dummy_Handler ;02:NMI
  955 0000000C 00000000        DCD              Dummy_Handler ;03:hard fault
  956 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
  957 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)
  958 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
  959 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
  960 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
  961 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
  962 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
  963 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (supervisor call)
  964 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
  965 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
  966 00000038 00000000        DCD              Dummy_Handler ;14:PendableSrvReq (pendable request 
  967 0000003C         ;   for system service)



ARM Macro Assembler    Page 26 


  968 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (system tick timer)
  969 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0 xfer complete/error
  970 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1 xfer complete/error
  971 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2 xfer complete/error
  972 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3 xfer complete/error
  973 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
  974 00000054 00000000        DCD              Dummy_Handler ;21:command complete; read collision
  975 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage detect;
  976 0000005C         ;   low-voltage warning
  977 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage wakeup
  978 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
  979 00000064 00000000        DCD              Dummy_Handler ;25:I2C1
  980 00000068 00000000        DCD              Dummy_Handler ;26:SPI0 (all IRQ sources)
  981 0000006C 00000000        DCD              Dummy_Handler ;27:SPI1 (all IRQ sources)
  982 00000070 00000000        DCD              Dummy_Handler ;28:UART0 (status; error)
  983 00000074 00000000        DCD              Dummy_Handler ;29:UART1 (status; error)
  984 00000078 00000000        DCD              Dummy_Handler ;30:UART2 (status; error)
  985 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
  986 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
  987 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
  988 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
  989 0000008C 00000000        DCD              Dummy_Handler ;35:TPM2
  990 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
  991 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
  992 00000098 00000000        DCD              Dummy_Handler ;38:PIT (all IRQ sources)
  993 0000009C 00000000        DCD              Dummy_Handler ;39:I2S0
  994 000000A0 00000000        DCD              Dummy_Handler ;40:USB0
  995 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
  996 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
  997 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
  998 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
  999 000000B4 00000000        DCD              Dummy_Handler ;45:Segment LCD
 1000 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA pin detect
 1001 000000BC 00000000        DCD              Dummy_Handler ;47:PORTC and PORTD pin detect
 1002 000000C0         
 1003 000000C0         
 1004 000000C0         
 1005 000000C0         __Vectors_End
 1006 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
 1007 000000C0                 ALIGN



ARM Macro Assembler    Page 27 


 1008 000000C0         ;****************************************************************
 1009 000000C0         ;Constants
 1010 000000C0                 AREA             MyConst,DATA,READONLY
 1011 00000000         ;>>>>> begin constants here <<<<<
 1012 00000000 54 79 70 
              65 20 61 
              20 71 75 
              65 75 65 
              20 63 6F 
              6D 6D 61 
              6E 64 20 
              28 64 2C 
              65 2C 68 
              2C 70 2C 
              73 29 3A 
              20 00    InitString
                               DCB              "Type a queue command (d,e,h,p,s): ",0
 1013 00000023         
 1014 00000023 46 61 69 
              6C 75 72 
              65 3A 20 
              00       Failure DCB              "Failure: ",0
 1015 0000002D         
 1016 0000002D 53 75 63 
              63 65 73 
              73 3A 20 
              00       Success DCB              "Success: ",0
 1017 00000037         
 1018 00000037 49 6E 3D 
              30 78 00 Ln      DCB              "In=0x",0
 1019 0000003D         
 1020 0000003D 53 74 61 
              74 75 73 
              3A 00    Status  DCB              "Status:",0
 1021 00000045         
 1022 00000045 64 20 28 
              64 65 71 
              75 65 75 
              65 29 2C 
              20 65 20 
              28 65 6E 
              71 75 65 



ARM Macro Assembler    Page 28 


              75 65 29 
              2C 20 68 
              20 28 68 
              65 6C 70 
              29 2C 20 
              70 20 28 
              70 72 69 
              6E 74 29 
              2C 20 73 
              20 28 73 
              74 61 74 
              75 73 29 
              00       Help    DCB              "d (dequeue), e (enqueue), h (help), p (print), s (status)",0
 1023 0000007F         
 1024 0000007F 20 4F 75 
              74 3D 30 
              78 00    OUT     DCB              " Out=0x",0
 1025 00000087         
 1026 00000087 4C 65 6E 
              67 74 68 
              3A 00    Length  DCB              "Length:",0
 1027 0000008F         
 1028 0000008F 20 4E 75 
              6D 3D 00 Num     DCB              " Num=",0
 1029 00000095         
 1030 00000095 43 68 61 
              72 61 63 
              74 65 72 
              20 74 6F 
              20 65 6E 
              71 75 65 
              75 65 3A 
              00       CTE     DCB              "Character to enqueue:",0
 1031 000000AB         
 1032 000000AB 3A 20 20 
              20 20 20 
              20 20 20 
              00       DQGDS   DCB              ":        ",0
 1033 000000B5         ;>>>>>   end constants here <<<<<
 1034 000000B5         
 1035 000000B5         
 1036 000000B5         



ARM Macro Assembler    Page 29 


 1037 000000B5         
 1038 000000B5         
 1039 000000B5         
 1040 000000B5 00 00 00        ALIGN
 1041 000000B8         ;****************************************************************
 1042 000000B8         ;Variables
 1043 000000B8                 AREA             MyData,DATA,READWRITE
 1044 00000000         ;>>>>> begin variables here <<<<<
 1045 00000000         
 1046 00000000         
 1047 00000000 00 00 00 
              00       QBuffer SPACE            Q_BUF_SZ
 1048 00000004                 ALIGN
 1049 00000004 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 QRecord SPACE            Q_REC_SZ
 1050 00000016 00 00           ALIGN
 1051 00000018 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 30 


              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00       String  SPACE            79
 1052 00000067         ;>>>>>   end variables here <<<<<
 1053 00000067 00              ALIGN
 1054 00000068                 END
Command Line: --debug --length=49 --width=120 --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --depend=".\objects
\exercise 07.d" -o".\objects\exercise 07.o" -I"D:\Assembly\Exercise 07\Code 07\RTE" -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_K
Lxx_DFP\1.6.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include --predefine="__UVISION_VERSION SETA 515" --predefine="MKL46Z
256xxx4 SETA 1" --list=.\listings\exercise 07.lst "Exercise 07.s"
